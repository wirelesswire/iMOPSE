optimizer\out\build\x64-Debug\CMakeFiles\3.31.6-msvc6\CompilerIdCXX\CMakeCXXCompilerId.cpp
=============
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"
# if __SUNPRO_CC >= 0x5100
   /* __SUNPRO_CC = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# endif

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"
  /* __HP_aCC = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"
  /* __DECCXX_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)

#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
# define COMPILER_ID "XL"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(__clang__) && defined(__cray__)
# define COMPILER_ID "CrayClang"
# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TASKING__)
# define COMPILER_ID "Tasking"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)

#elif defined(__ORANGEC__)
# define COMPILER_ID "OrangeC"
# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__) && defined(__ti__)
# define COMPILER_ID "TIClang"
  # define COMPILER_VERSION_MAJOR DEC(__ti_major__)
  # define COMPILER_VERSION_MINOR DEC(__ti_minor__)
  # define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
# define COMPILER_VERSION_INTERNAL DEC(__ti_version__)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__) || defined(__GNUG__)
# define COMPILER_ID "GNU"
# if defined(__GNUC__)
#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# else
#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__clang__) && defined(__ti__)
# if defined(__ARM_ARCH)
#  define ARCHITECTURE_ID "ARM"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#elif defined(__TASKING__)

# if defined(__CTC__) || defined(__CPTC__)
#  define ARCHITECTURE_ID "TriCore"

# elif defined(__CMCS__)
#  define ARCHITECTURE_ID "MCS"

# elif defined(__CARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__CARC__)
#  define ARCHITECTURE_ID "ARC"

# elif defined(__C51__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__CPCP__)
#  define ARCHITECTURE_ID "PCP"

# else
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#define CXX_STD_98 199711L
#define CXX_STD_11 201103L
#define CXX_STD_14 201402L
#define CXX_STD_17 201703L
#define CXX_STD_20 202002L
#define CXX_STD_23 202302L

#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > CXX_STD_17
#    define CXX_STD _MSVC_LANG
#  elif _MSVC_LANG == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14 && __cplusplus > CXX_STD_17
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14
#    define CXX_STD CXX_STD_17
#  elif defined(__INTEL_CXX11_MODE__) && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  elif defined(__INTEL_CXX11_MODE__)
#    define CXX_STD CXX_STD_11
#  else
#    define CXX_STD CXX_STD_98
#  endif
#elif defined(_MSC_VER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > __cplusplus
#    define CXX_STD _MSVC_LANG
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__NVCOMPILER)
#  if __cplusplus == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__INTEL_COMPILER) || defined(__PGI)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_namespace_attributes)
#    define CXX_STD CXX_STD_17
#  elif __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif (defined(__IBMCPP__) || defined(__ibmxl__)) && defined(__linux__)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif __cplusplus == 1 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#  define CXX_STD CXX_STD_11
#else
#  define CXX_STD __cplusplus
#endif

const char* info_language_standard_default = "INFO" ":" "standard_default["
#if CXX_STD > CXX_STD_23
  "26"
#elif CXX_STD > CXX_STD_20
  "23"
#elif CXX_STD > CXX_STD_17
  "20"
#elif CXX_STD > CXX_STD_14
  "17"
#elif CXX_STD > CXX_STD_11
  "14"
#elif CXX_STD >= CXX_STD_11
  "11"
#else
  "98"
#endif
"]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__)) &&                                     \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#ifdef COMPILER_VERSION_INTERNAL
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}


optimizer\out\build\x64-Release\CMakeFiles\3.31.6-msvc6\CompilerIdCXX\CMakeCXXCompilerId.cpp
=============
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"
# if __SUNPRO_CC >= 0x5100
   /* __SUNPRO_CC = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# endif

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"
  /* __HP_aCC = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"
  /* __DECCXX_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)

#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
# define COMPILER_ID "XL"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(__clang__) && defined(__cray__)
# define COMPILER_ID "CrayClang"
# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TASKING__)
# define COMPILER_ID "Tasking"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)

#elif defined(__ORANGEC__)
# define COMPILER_ID "OrangeC"
# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__) && defined(__ti__)
# define COMPILER_ID "TIClang"
  # define COMPILER_VERSION_MAJOR DEC(__ti_major__)
  # define COMPILER_VERSION_MINOR DEC(__ti_minor__)
  # define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
# define COMPILER_VERSION_INTERNAL DEC(__ti_version__)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__) || defined(__GNUG__)
# define COMPILER_ID "GNU"
# if defined(__GNUC__)
#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# else
#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__clang__) && defined(__ti__)
# if defined(__ARM_ARCH)
#  define ARCHITECTURE_ID "ARM"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#elif defined(__TASKING__)

# if defined(__CTC__) || defined(__CPTC__)
#  define ARCHITECTURE_ID "TriCore"

# elif defined(__CMCS__)
#  define ARCHITECTURE_ID "MCS"

# elif defined(__CARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__CARC__)
#  define ARCHITECTURE_ID "ARC"

# elif defined(__C51__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__CPCP__)
#  define ARCHITECTURE_ID "PCP"

# else
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#define CXX_STD_98 199711L
#define CXX_STD_11 201103L
#define CXX_STD_14 201402L
#define CXX_STD_17 201703L
#define CXX_STD_20 202002L
#define CXX_STD_23 202302L

#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > CXX_STD_17
#    define CXX_STD _MSVC_LANG
#  elif _MSVC_LANG == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14 && __cplusplus > CXX_STD_17
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14
#    define CXX_STD CXX_STD_17
#  elif defined(__INTEL_CXX11_MODE__) && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  elif defined(__INTEL_CXX11_MODE__)
#    define CXX_STD CXX_STD_11
#  else
#    define CXX_STD CXX_STD_98
#  endif
#elif defined(_MSC_VER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > __cplusplus
#    define CXX_STD _MSVC_LANG
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__NVCOMPILER)
#  if __cplusplus == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__INTEL_COMPILER) || defined(__PGI)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_namespace_attributes)
#    define CXX_STD CXX_STD_17
#  elif __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif (defined(__IBMCPP__) || defined(__ibmxl__)) && defined(__linux__)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif __cplusplus == 1 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#  define CXX_STD CXX_STD_11
#else
#  define CXX_STD __cplusplus
#endif

const char* info_language_standard_default = "INFO" ":" "standard_default["
#if CXX_STD > CXX_STD_23
  "26"
#elif CXX_STD > CXX_STD_20
  "23"
#elif CXX_STD > CXX_STD_17
  "20"
#elif CXX_STD > CXX_STD_14
  "17"
#elif CXX_STD > CXX_STD_11
  "14"
#elif CXX_STD >= CXX_STD_11
  "11"
#else
  "98"
#endif
"]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__)) &&                                     \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#ifdef COMPILER_VERSION_INTERNAL
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}


optimizer\src\CProgram.cpp
=============
#include <iostream>
#include <chrono>
#include "CProgram.h"
#include "problem/AProblem.h"
#include "factories/problem/CProblemFactory.h"
#include "utils/random/CRandom.h"
#include "method/AMethod.h"
#include "factories/method/CMethodFactory.h"
#include "utils/logger/CExperimentLogger.h"

// Initialize a static member variable of AMethod to count the number of experiment runs
int AMethod::m_ExperimentRunCounter = 0;

// Define the 'Run' method of the CProgram class, which executes the main program logic
void CProgram::Run(const SProgramParams &programParams)
{
    // Create a problem instance using the factory pattern based on provided program parameters
    AProblem *problem = CProblemFactory::CreateProblem(
            programParams.m_ProblemName,
            programParams.m_ProblemInstancePath
    );

    // Create a method instance using the factory pattern and the created problem
    AMethod *method = CMethodFactory::CreateMethod(
            programParams.m_MethodConfigPath,
            *problem
    );

    // Initialize a random number generator
    CRandom::SetSeed(programParams.m_Seed);

    // Loop through the number of executions specified in the program parameters
    for (int i = 0; i < programParams.m_ExecutionsCount; i++, AMethod::m_ExperimentRunCounter++)
    {
        CRandom::SetSeed(programParams.m_Seed+i);

        // Create a prefix for output data paths for each experiment run
        CExperimentLogger::CreateOutputDataPrefix();

        // Record the start time of the optimization process
        auto start = std::chrono::high_resolution_clock::now();

        // Output a message indicating the start of an optimization run
        std::cout << "Optimization run #" << i << " ongoing ..." << std::endl;

        // Run the optimization process and then reset the method for the next iteration
        method->RunOptimization();
        method->Reset();

        // Record the end time, calculate, and output the duration of the optimization
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "Finished in " << duration.count() << "ms" << std::endl;
    }

    // Clean up and delete objects created by the problem and method factories
    CProblemFactory::DeleteObjects();
    CMethodFactory::DeleteObjects();

    // Free the memory allocated for 'method' and 'problem' pointers
    delete method;
    delete problem;
}

optimizer\src\main.cpp
=============
#include <iostream> // Standard I/O library
#include <random> // Library for random number generation
#include "SProgramParams.h" // Custom header file for program parameters structure
#include "CProgram.h" // Custom header file for the main program class
#include "utils/logger/CExperimentLogger.h" // Custom header for an experiment logger utility class
#include "utils/fileReader/CReadUtils.h"  // Custom header for a file reader utility class

#define DEBUG 1 // Define DEBUG as 0 to disable debug output; set to 1 to enable

static const int MIN_REQUIRED_ARGS = 4; // Minimum number of arguments required for the program
static const int OPTIMIZER_CONFIG_INDEX = 1; // Index in argv for optimizer configuration file
static const int PROBLEM_NAME_INDEX = 2; // Index in argv for problem name
static const int PROBLEM_DEFINITION_INDEX = 3; // Index in argv for problem definition file
static const int OUTPUT_DIR_PATH_INDEX = 4; // Index in argv for output path directory where results and experiments will be logged
static const int EXECUTION_COUNT_INDEX = 5; // Index in argv for the number of executions
static const int SEED_INDEX = 6; // Index in argv for the number of executions

static const int DEFAULT_EXECUTIONS_NUMBER = 1; // Default number of executions if not specified

void showErrorAndExit(const char *message, const char *detail = ""); // Function prototype for error handling



int main(int argc, char *argv[])
{

#if DEBUG
    for (int i = 0; i < argc; ++i) // Print all command line arguments for debugging
    {
        std::cout << "Argument " << i << ": " << argv[i] << std::endl;
    }
#endif // DEBUG

   
    // Check for minimum number of arguments
    if (argc < MIN_REQUIRED_ARGS)
    {
        // Print usage instructions if not enough arguments
        std::cerr << "Usage: " << argv[0]
                  << " <MethodConfigPath> <ProblemName> <ProblemInstancePath> <OutputDirectory> [ExecutionsCount] [Seed]"
                  << std::endl;
        return -1;
    }

    SProgramParams programParams{}; // Initialize program parameters

    // Check if optimizer configuration file exists
    if (!CReadUtils::fileExists(argv[OPTIMIZER_CONFIG_INDEX]))
    {
        showErrorAndExit("The provided OptimizerConfigPath does not exist: ", argv[OPTIMIZER_CONFIG_INDEX]);
    }
    programParams.m_MethodConfigPath = argv[OPTIMIZER_CONFIG_INDEX]; // Set optimizer configuration path

    programParams.m_ProblemName = argv[PROBLEM_NAME_INDEX]; // Set problem name

    // Check if problem definition file exists
    if (!CReadUtils::fileExists(argv[PROBLEM_DEFINITION_INDEX]))
    {
        showErrorAndExit("The provided ProblemDefinitionPath does not exist: ", argv[PROBLEM_DEFINITION_INDEX]);
    }
    programParams.m_ProblemInstancePath = argv[PROBLEM_DEFINITION_INDEX]; // Set problem definition path

    CExperimentLogger::m_OutputDirPath = argv[OUTPUT_DIR_PATH_INDEX];  // Set output directory

    // Set the number of executions, default if not provided
    programParams.m_ExecutionsCount = (argc > EXECUTION_COUNT_INDEX) ?
                                      std::stoi(argv[EXECUTION_COUNT_INDEX]) :
                                      DEFAULT_EXECUTIONS_NUMBER;

    std::random_device rd;
    programParams.m_Seed = (argc > SEED_INDEX) ? std::stoi(argv[SEED_INDEX]) : rd();
    
    CProgram::Run(programParams);

    return 0;
}

void showErrorAndExit(const char *message, const char *detail)
{
    std::cerr << "Error: " << message << detail << std::endl; // Print error message
    exit(-1); // Exit the program with an error code
}

optimizer\src\factories\method\CMethodFactory.cpp
=============
#include "CMethodFactory.h"
#include "configMap/CConfigFactory.h"
#include "methods/SO/GA/CGAFactory.h"
#include "methods/SO/SA/CSAFactory.h"
#include "methods/SO/TS/CTSFactory.h"
#include "methods/MO/NTGA2/CNTGA2Factory.h"
#include "methods/MO/NTGA2_ALNS/CNTGA2_ALNSFactory.h"
#include "methods/MO/NSGAII/CNSGAIIFactory.h"
#include "methods/SO/ACO/CACOFactory.h"
#include "operators/initialization/CInitializationFactory.h"
#include "operators/crossover/CCrossoverFactory.h"
#include "operators/mutation/CMutationFactory.h"
#include "operators/mutation/CALNSMutationFactory.h"
#include "methods/SO/PSO/CPSOFactory.h"
#include <cstring>
#include "methods/SO/DE/CDEFactory.h"
#include "methods/MO/MOEAD/CMOEADFactory.h"
#include "methods/MO/ANTGA/CANTGAFactory.h"
#include "methods/MO/BNTGA/CBNTGAFactory.h"
#include "methods/MO/SPEA2/CSPEA2Factory.h"
#include "../../utils/fileReader/CReadUtils.h"

// Static members of CMethodFactory, initialized to nullptr. These will hold various components of an optimization method.
SConfigMap* CMethodFactory::configMap = nullptr;
AInitialization* CMethodFactory::initialization = nullptr;
ACrossover* CMethodFactory::crossover = nullptr;
AMutation* CMethodFactory::mutation = nullptr;

// Static method to create an optimization method based on a configuration file and a problem instance.
AMethod* CMethodFactory::CreateMethod(
        const char* optimizerConfigPath,
        AProblem& problem
)
{
    // Create a configuration map from the provided path using the CConfigFactory.
    configMap = CConfigFactory::CreateConfigMap(optimizerConfigPath);
    if (configMap == nullptr) {
        throw std::runtime_error("Error while reading method configuration");
    }

    std::string methodName;
    // Extract the method name from the configuration map. If it's not provided, throw an error.
    if (!configMap->TakeValue("MethodName", methodName)) {
        throw std::runtime_error("MethodName not provided in method configuration");
    }

    // Create initialization strategy based on the configuration map.
    initialization = CInitializationFactory::Create(configMap, problem);

    // Create and return a specific optimization method based on the method name.
    if (strcmp(methodName.c_str(), "ACO") == 0)
        return CACOFactory::CreateACO(configMap, problem, initialization, optimizerConfigPath);
    if (strcmp(methodName.c_str(), "SA") == 0)
        return CSAFactory::CreateSA(configMap, problem, initialization);
    if (strcmp(methodName.c_str(), "TS") == 0)
        return CTSFactory::CreateTS(configMap, problem, initialization);
    if (strcmp(methodName.c_str(), "DE") == 0)
        return CDEFactory::CreateDE(configMap, problem, initialization);
    if (strcmp(methodName.c_str(), "PSO") == 0)
        return CPSOFactory::CreatePSO(configMap, problem, initialization);

    // Create crossover and mutation strategies based on the configuration map.
    crossover = CCrossoverFactory::Create(configMap, "Crossover", problem);
    if (crossover == nullptr) {
        throw std::runtime_error("Error while reading crossover configuration");
    }
    mutation = CMutationFactory::Create(configMap, "Mutation", problem);
    if (mutation == nullptr) {
        throw std::runtime_error("Error while reading mutation configuration");
    }
    
    if (strcmp(methodName.c_str(), "GA") == 0)
        return CGAFactory::CreateGA(configMap, problem, initialization, crossover, mutation);
    if (strcmp(methodName.c_str(), "NTGA2") == 0)
        return CNTGA2Factory::CreateNTGA2(configMap, problem, initialization, crossover, mutation);
    if (strcmp(methodName.c_str(), "NSGAII") == 0)
        return CNSGAIIFactory::CreateNSGAII(configMap, problem, initialization, crossover, mutation);
    if (strcmp(methodName.c_str(), "MOEAD") == 0)
        return CMOEADFactory::CreateMOEAD(configMap, problem, initialization, crossover, mutation);
    if (strcmp(methodName.c_str(), "ANTGA") == 0)
        return CANTGAFactory::CreateANTGA(configMap, problem, initialization, crossover, mutation);
    if (strcmp(methodName.c_str(), "BNTGA") == 0)
        return CBNTGAFactory::CreateBNTGA(configMap, problem, initialization, crossover, mutation);
    if (strcmp(methodName.c_str(), "SPEA2") == 0)
        return CSPEA2Factory::CreateSPEA2(configMap, problem, initialization, crossover, mutation);
    if (strcmp(methodName.c_str(), "NTGA2_ALNS") == 0) 
    {
        return CNTGA2_ALNSFactory::CreateNTGA2_ALNS(configMap,
            problem,
            initialization,
            crossover,
            mutation,
            CALNSMutationFactory::CreateRemovalOperators(problem),
            CALNSMutationFactory::CreateInsertionOperators(problem)
        );
    }
    
    // If the method name is not supported, throw an error.
    throw std::runtime_error("Method name: " + std::string(methodName) + " not supported");
}

// Static method to delete the objects created by the factory.
void CMethodFactory::DeleteObjects() {
    // Delete the created objects (configMap, initialization, crossover, mutation)
    delete configMap;
    delete initialization;
    if (crossover != nullptr)
        delete crossover;
    if (mutation != nullptr)
        delete mutation;

    // Call the DeleteObjects methods of other factories involved in creating the method components.
    CGAFactory::DeleteObjects();
    CSAFactory::DeleteObjects();
    CTSFactory::DeleteObjects();
    CNTGA2Factory::DeleteObjects();
    CNSGAIIFactory::DeleteObjects();
    CPSOFactory::DeleteObjects();
    CMOEADFactory::DeleteObjects();
    CBNTGAFactory::DeleteObjects();
    CSPEA2Factory::DeleteObjects();
    CACOFactory::DeleteObjects();
    CNTGA2_ALNSFactory::DeleteObjects();
}


optimizer\src\factories\method\configMap\CConfigFactory.cpp
=============

#include "CConfigFactory.h"
#include "../../../utils/fileReader/CReadUtils.h"

SConfigMap *CConfigFactory::CreateConfigMap(const char *path)
{
    auto *configMap = new SConfigMap();

    std::ifstream readFileStream(path);

    std::string line;
    while (std::getline(readFileStream, line))
    {
        line.erase(std::remove(line.begin(), line.end(), '\r'), line.end());

        std::string keyString, valueString;
        if (CReadUtils::ReadKeyValueString(line, " ", keyString, valueString))
        {
            if (!configMap->AddLine(keyString, valueString))
            {
                std::cerr << "Key: " << keyString << "is already present in the config: " << path << std::endl;
                return nullptr;
            }
        }
        else
        {
            std::cerr << "Cannot parse line: " << line << " while reading config: " << path << std::endl;
            return nullptr;
        }
    }

    readFileStream.close();

    return configMap;
}


optimizer\src\factories\method\methods\MO\ANTGA\CANTGAFactory.cpp
=============
#include "CANTGAFactory.h"
#include "../../../operators/selection/CSelectionFactory.h"

CGapSelectionByRandomDim* CANTGAFactory::gapSelectionByRandomDim = nullptr;

CANTGA* CANTGAFactory::CreateANTGA(SConfigMap* configMap, AProblem& problem, AInitialization* initialization,
                                   ACrossover* crossover, AMutation* mutation)
{
    gapSelectionByRandomDim = CSelectionFactory::CreateGapSelection(configMap, true);

    return new CANTGA(
        problem,
        *initialization,
        *crossover,
        *mutation,
        *gapSelectionByRandomDim,
        configMap
    );
}

void CANTGAFactory::DeleteObjects()
{
    delete gapSelectionByRandomDim;
}


optimizer\src\factories\method\methods\MO\BNTGA\CBNTGAFactory.cpp
=============
#include "CBNTGAFactory.h"
#include "../../../operators/selection/CSelectionFactory.h"

CGapSelectionByRandomDim *CBNTGAFactory::gapSelectionByRandomDim = nullptr;

CBNTGA *CBNTGAFactory::CreateBNTGA(SConfigMap *configMap, AProblem &problem, AInitialization *initialization,
                                   ACrossover *crossover, AMutation *mutation)
{
    gapSelectionByRandomDim = CSelectionFactory::CreateGapSelection(configMap, true);
    
    return new CBNTGA(
            problem,
            *initialization,
            *crossover,
            *mutation,
            *gapSelectionByRandomDim,
            configMap
    );
}

void CBNTGAFactory::DeleteObjects()
{
    delete gapSelectionByRandomDim;
}


optimizer\src\factories\method\methods\MO\MOEAD\CMOEADFactory.cpp
=============

#include "CMOEADFactory.h"
#include "../../../operators/mutation/CMutationFactory.h"
#include "../../../operators/crossover/CCrossoverFactory.h"
#include "../../../operators/selection/CSelectionFactory.h"
#include "../../../operators/initialization/CInitializationFactory.h"


CMOEAD *CMOEADFactory::CreateMOEAD(SConfigMap *configMap, AProblem &problem, AInitialization *initialization, ACrossover *crossover, AMutation *mutation)
{
    return new CMOEAD(
            problem,
            *initialization,
            *crossover,
            *mutation,
            configMap
    );
}

void CMOEADFactory::DeleteObjects()
{

}


optimizer\src\factories\method\methods\MO\NSGAII\CNSGAIIFactory.cpp
=============

#include "CNSGAIIFactory.h"
#include "../../../operators/mutation/CMutationFactory.h"
#include "../../../operators/crossover/CCrossoverFactory.h"
#include "../../../operators/selection/CSelectionFactory.h"
#include "../../../operators/initialization/CInitializationFactory.h"

CRankedTournament *CNSGAIIFactory::rankedTournament = nullptr;

CNSGAII *CNSGAIIFactory::CreateNSGAII(SConfigMap *configMap, AProblem &problem, AInitialization *initialization,
                                      ACrossover *crossover,
                                      AMutation *mutation)
{
    rankedTournament = CSelectionFactory::CreateRankedTournamentSelection(configMap);

    return new CNSGAII(
            problem,
            *initialization,
            *rankedTournament,
            *crossover,
            *mutation,
            configMap
    );
}

void CNSGAIIFactory::DeleteObjects()
{
    delete rankedTournament;
}


optimizer\src\factories\method\methods\MO\NTGA2\CNTGA2Factory.cpp
=============

#include "CNTGA2Factory.h"
#include "../../../operators/initialization/CInitializationFactory.h"
#include "../../../operators/selection/CSelectionFactory.h"
#include "../../../operators/mutation/CMutationFactory.h"
#include "../../../operators/crossover/CCrossoverFactory.h"

CRankedTournament *CNTGA2Factory::rankedTournament = nullptr;
CGapSelectionByRandomDim *CNTGA2Factory::gapSelectionByRandomDim = nullptr;

CNTGA2 *CNTGA2Factory::CreateNTGA2(SConfigMap *configMap, AProblem &problem, AInitialization *initialization,
                                   ACrossover *crossover,
                                   AMutation *mutation)
{

    rankedTournament = CSelectionFactory::CreateRankedTournamentSelection(configMap);
    gapSelectionByRandomDim = CSelectionFactory::CreateGapSelection(configMap, false);

    return new CNTGA2(
            problem,
            *initialization,
            *rankedTournament,
            *gapSelectionByRandomDim,
            *crossover,
            *mutation,
            configMap
    );
}

void CNTGA2Factory::DeleteObjects()
{
    delete rankedTournament;
    delete gapSelectionByRandomDim;
}


optimizer\src\factories\method\methods\MO\NTGA2_ALNS\CNTGA2_ALNSFactory.cpp
=============

#include "CNTGA2_ALNSFactory.h"
#include "../../../operators/initialization/CInitializationFactory.h"
#include "../../../operators/selection/CSelectionFactory.h"
#include "../../../operators/mutation/CMutationFactory.h"
#include "../../../operators/crossover/CCrossoverFactory.h"

CRankedTournament * CNTGA2_ALNSFactory::rankedTournament = nullptr;
CGapSelectionByRandomDim * CNTGA2_ALNSFactory::gapSelectionByRandomDim = nullptr;
std::vector<AMutation*>* CNTGA2_ALNSFactory::s_alnsRemovalMutations;
std::vector<AMutation*>* CNTGA2_ALNSFactory::s_alnsInsertionMutations;

CNTGA2_ALNS * CNTGA2_ALNSFactory::CreateNTGA2_ALNS(SConfigMap *configMap
    , AProblem &problem
    , AInitialization *initialization
    , ACrossover *crossover
    , AMutation *mutation
    , std::vector<AMutation*>* alnsRemovalMutations
    , std::vector<AMutation*>* alnsInsertionMutations
)
{

    rankedTournament = CSelectionFactory::CreateRankedTournamentSelection(configMap);
    gapSelectionByRandomDim = CSelectionFactory::CreateGapSelection(configMap, false);
    s_alnsInsertionMutations = alnsInsertionMutations;
    s_alnsRemovalMutations = alnsRemovalMutations;


    return new CNTGA2_ALNS(
            problem,
            *initialization,
            *rankedTournament,
            *gapSelectionByRandomDim,
            *crossover,
            *mutation,
            configMap,
            *s_alnsRemovalMutations,
            *s_alnsInsertionMutations
    );
}

void CNTGA2_ALNSFactory::DeleteObjects()
{
    delete rankedTournament;
    delete gapSelectionByRandomDim;
    for (int i = 0; i < s_alnsRemovalMutations->size(); i++) {
        delete (*s_alnsRemovalMutations)[i];
    }
    for (int i = 0; i < s_alnsInsertionMutations->size(); i++) {
        delete (*s_alnsInsertionMutations)[i];
    }
    delete s_alnsInsertionMutations;
    delete s_alnsRemovalMutations;
}


optimizer\src\factories\method\methods\MO\SPEA2\CSPEA2Factory.cpp
=============
#include "CSPEA2Factory.h"

CSPEA2 *CSPEA2Factory::CreateSPEA2(SConfigMap *configMap, AProblem &problem, AInitialization *initialization,
                                   ACrossover *crossover,
                                   AMutation *mutation)
{
    return new CSPEA2(
            problem,
            *initialization,
            *crossover,
            *mutation,
            configMap
    );
}

void CSPEA2Factory::DeleteObjects()
{

}

optimizer\src\factories\method\methods\SO\ACO\CACOFactory.cpp
=============
#include <stdexcept>
#include "CACOFactory.h"
#include "../../../../../utils/fileReader/CReadUtils.h"
#include <string>

std::vector<float> *CACOFactory::objectiveWeights = nullptr;

CACO *CACOFactory::CreateACO(SConfigMap *configMap, AProblem &problem, AInitialization *initialization,const char *optimizerConfigPath) {
    objectiveWeights = new std::vector<float>();
    std::string rawWeightsString;
    configMap->TakeValue("ObjectiveWeights", rawWeightsString);

    if (!rawWeightsString.empty())
    {
        CReadUtils::ReadWeights(rawWeightsString, *objectiveWeights);
    } else {
        *objectiveWeights = {1.0f};
    }

    std::string strVariable(optimizerConfigPath);
    
    if (strVariable.find("CVRP") != std::string::npos) {
        return new CACO_TSP(
                problem,
                *initialization,
                configMap,
                *objectiveWeights
        );
    }
    throw std::runtime_error("Method ACO not supported for problem " + std::string(optimizerConfigPath) );
}

void CACOFactory::DeleteObjects() {
    delete objectiveWeights;
}


optimizer\src\factories\method\methods\SO\DE\CDEFactory.cpp
=============
#include <stdexcept>
#include "CDEFactory.h"
#include "../../../../../utils/fileReader/CReadUtils.h"

std::vector<float>* CDEFactory::objectiveWeights = nullptr;

CDE* CDEFactory::CreateDE(SConfigMap* configMap, AProblem& problem, AInitialization* initialization)
{
    objectiveWeights = new std::vector<float>();
    std::string rawWeightsString;
    configMap->TakeValue("ObjectiveWeights", rawWeightsString);

    if (!rawWeightsString.empty())
    {
        CReadUtils::ReadWeights(rawWeightsString, *objectiveWeights);
    } else {
        *objectiveWeights = {1.0f};
    }

    return new CDE(
            *objectiveWeights,
            problem,
            *initialization,
            configMap
    );
}

void CDEFactory::DeleteObjects()
{
    delete objectiveWeights;
}


optimizer\src\factories\method\methods\SO\GA\CGAFactory.cpp
=============

#include <stdexcept>
#include "CGAFactory.h"
#include "../../../../../utils/fileReader/CReadUtils.h"
#include "../../../operators/selection/CSelectionFactory.h"

std::vector<float> *CGAFactory::objectiveWeights = nullptr;
CFitnessTournament *CGAFactory::fitnessTournament = nullptr;

CGA *CGAFactory::CreateGA(SConfigMap *configMap, AProblem &problem, AInitialization *initialization,
                          ACrossover *crossover,
                          AMutation *mutation)
{
    objectiveWeights = new std::vector<float>();
    std::string rawWeightsString;
    configMap->TakeValue("ObjectiveWeights", rawWeightsString);

    if (!rawWeightsString.empty())
    {
        CReadUtils::ReadWeights(rawWeightsString, *objectiveWeights);
    } else {
        *objectiveWeights = {1.0f};
    }
    
    fitnessTournament = CSelectionFactory::CreateFitnessTournamentSelection(configMap);

    return new CGA(
            *objectiveWeights,
            problem,
            *initialization,
            *fitnessTournament,
            *crossover,
            *mutation,
            configMap
    );
}

void CGAFactory::DeleteObjects()
{
    delete objectiveWeights;
    delete fitnessTournament;
}


optimizer\src\factories\method\methods\SO\PSO\CPSOFactory.cpp
=============
#include "CPSOFactory.h"
#include <stdexcept>
#include "../../../../../utils/fileReader/CReadUtils.h"
#include "../../../../../method/methods/SO/PSO/CPSO.h"

std::vector<float>* CPSOFactory::objectiveWeights = nullptr;

CPSO* CPSOFactory::CreatePSO(SConfigMap* configMap, AProblem& problem, AInitialization* initialization)
{
    objectiveWeights = new std::vector<float>();
    std::string rawWeightsString;
    configMap->TakeValue("ObjectiveWeights", rawWeightsString);

    if (!rawWeightsString.empty())
    {
        CReadUtils::ReadWeights(rawWeightsString, *objectiveWeights);
    } else {
        *objectiveWeights = {1.0f};
    }

    return new CPSO(
        *objectiveWeights,
        problem,
        *initialization,
        configMap
    );
}

void CPSOFactory::DeleteObjects()
{
    delete objectiveWeights;
}


optimizer\src\factories\method\methods\SO\SA\CSAFactory.cpp
=============
#include <stdexcept>
#include "CSAFactory.h"
#include "../../../../../utils/fileReader/CReadUtils.h"

std::vector<float>* CSAFactory::objectiveWeights = nullptr;

CSA* CSAFactory::CreateSA(SConfigMap* configMap, AProblem& problem, AInitialization* initialization)
{
    objectiveWeights = new std::vector<float>();
    std::string rawWeightsString;
    configMap->TakeValue("ObjectiveWeights", rawWeightsString);
    if (!rawWeightsString.empty())
    {
        CReadUtils::ReadWeights(rawWeightsString, *objectiveWeights);
    } else {
        *objectiveWeights = {1.0f};
    }

    return new CSA(
            *objectiveWeights,
            problem,
            *initialization,
            configMap
    );
}

void CSAFactory::DeleteObjects()
{
    delete objectiveWeights;
}

optimizer\src\factories\method\methods\SO\TS\CTSFactory.cpp
=============
#include <stdexcept>
#include "CTSFactory.h"
#include "../../../../../utils/fileReader/CReadUtils.h"

std::vector<float>* CTSFactory::objectiveWeights = nullptr;
// Other specific members for CTS

CTS* CTSFactory::CreateTS(SConfigMap* configMap, AProblem& problem, AInitialization* initialization)
{
    objectiveWeights = new std::vector<float>();
    std::string rawWeightsString;
    configMap->TakeValue("ObjectiveWeights", rawWeightsString);
    if (!rawWeightsString.empty())
    {
        CReadUtils::ReadWeights(rawWeightsString, *objectiveWeights);
    } else {
        *objectiveWeights = {1.0f};
    }

    // Additional TA-specific configuration handling goes here

    return new CTS(
            *objectiveWeights,
            problem,
            *initialization,
            configMap
    );
}

void CTSFactory::DeleteObjects()
{
    delete objectiveWeights;
    // Cleanup for other specific members
}

optimizer\src\factories\method\operators\crossover\CCrossoverFactory.cpp
=============

#include <regex>
#include <cstring>
#include "CCrossoverFactory.h"
#include "method/operators/crossover/crossovers/CUniformCX.h"
#include "method/operators/crossover/crossovers/CTTP_OS_SX.h"
#include "method/operators/crossover/crossovers/CCVRP_OX.h"
#include "utils/fileReader/CReadUtils.h"

ACrossover *CCrossoverFactory::Create(SConfigMap *configMap, const std::string& configKey, AProblem& problem)
{
    std::string rawCrossoverString;
    if (!configMap->TakeValue(configKey, rawCrossoverString))
    {
        return nullptr;
    }

    auto const vec = CReadUtils::SplitLine(rawCrossoverString);
    const char *opName = vec[0].c_str();

    const std::set<EEncodingType> &encodingTypes = GetAllEncodingTypes(problem.GetProblemEncoding().m_Encoding);
    if (strcmp(opName, "UniformCX" ) == 0 && (encodingTypes.find(EEncodingType::ASSOCIATION) != encodingTypes.end() || encodingTypes.find(EEncodingType::PERMUTATION) != encodingTypes.end()))
    {
        float cxProb = std::stof(vec[1]);
        return new CUniformCX(cxProb);
    }
    else if (strcmp(opName, "TTP_OX_SX") == 0 && encodingTypes.find(EEncodingType::PERMUTATION) != encodingTypes.end())
    {
        float routeCrProb = std::stof(vec[1]);
        float knapCrProb = std::stof(vec[2]);
        return new CTTP_OS_SX(routeCrProb, knapCrProb);
    }
    else if (strcmp(opName, "CVRP_OX") == 0 && encodingTypes.find(EEncodingType::PERMUTATION) != encodingTypes.end())
    {
        float oxProb = std::stof(vec[1]);
        return new CCVRP_OX(oxProb);
    }

    return nullptr;
}

std::set<EEncodingType> CCrossoverFactory::GetAllEncodingTypes(const std::vector<SEncodingSection> &encoding)
{
    std::set<EEncodingType> uniqueTypes;

    for (const auto &section: encoding)
    {
        uniqueTypes.insert(section.m_SectionType);
    }

    return uniqueTypes;
}

optimizer\src\factories\method\operators\initialization\CInitializationFactory.cpp
=============

#include <stdexcept>
#include <cstring>
#include "CInitializationFactory.h"
#include "method/operators/initialization/initializations/CInitialization.h"
#include "method/operators/initialization/initializations/CECVRPTWInitialization.h"

AInitialization *CInitializationFactory::Create(SConfigMap* configMap, AProblem& problem)
{
    std::string initializationName;

    if (!configMap->TakeValue("InitializationName", initializationName)) {
        return new CInitialization();
    }

    if (strcmp(initializationName.c_str(), "ECVRPTW") == 0)
        return new CECVRPTWInitialization(dynamic_cast<CECVRPTW&>(problem));

    throw std::runtime_error("Initialization name: " + std::string(initializationName) + " not supported");
}


optimizer\src\factories\method\operators\mutation\CALNSMutationFactory.cpp
=============
#include <regex>
#include <cstring>
#include "CALNSMutationFactory.h"
#include "method/operators/mutation/mutations/ECVRPTW/CECVRPTWRandomClientRemoval.h"
#include "method/operators/mutation/mutations/ECVRPTW/CECVRPTWShawClientRemoval.h"
#include "method/operators/mutation/mutations/ECVRPTW/CECVRPTWRandomClientInsertion.h"
#include "method/operators/mutation/mutations/ECVRPTW/CECVRPTWShawClientInsertion.h"
#include "problem/problems/ECVRPTW/CECVRPTW.h"

std::vector<AMutation*>* CALNSMutationFactory::CreateRemovalOperators(AProblem& problem)
{
    auto randomClientRemoval = new CECVRPTWRandomClientRemoval(dynamic_cast<CECVRPTW&>(problem));
    auto shawClientRemoval = new CECVRPTWShawClientRemoval(dynamic_cast<CECVRPTW&>(problem));
    return new std::vector<AMutation*>{ randomClientRemoval, shawClientRemoval };
}

std::vector<AMutation*>* CALNSMutationFactory::CreateInsertionOperators(AProblem& problem)
{
    auto greedyClientInsertion = new CECVRPTWRandomClientInsertion(dynamic_cast<CECVRPTW&>(problem));
    auto shawClientInsertion = new CECVRPTWShawClientInsertion(dynamic_cast<CECVRPTW&>(problem));
    return new std::vector<AMutation*>{ greedyClientInsertion, shawClientInsertion };
}

optimizer\src\factories\method\operators\mutation\CMultiMutationFactory.cpp
=============
#include <cstring>
#include "CMultiMutationFactory.h"
#include "CMutationFactory.h"
#include "method/multiOperator/operatorSelectors/CUniformMultiOperator.h"
#include "method/multiOperator/operatorSelectors/CCreditRouletteMultiOperator.h"
#include "method/multiOperator/operatorSelectors/CInvCreditRouletteMultiOperator.h"
#include "utils/fileReader/CReadUtils.h"

AMultiOperator<AMutation>* CMultiMutationFactory::Create(SConfigMap* configMap, AProblem& problem)
{
    // TODO - implement other options

    std::string rawString;
    if (!configMap->TakeValue("MultiMutation", rawString))
    {
        return nullptr;
    }

    auto const vec = CReadUtils::SplitLine(rawString);
    const char *opName = vec[0].c_str();

    AMultiOperator<AMutation>* multiOperator = nullptr;
    if (strcmp(opName, "UniformMultiOperator") == 0)
    {
        multiOperator = new CUniformMultiOperator<AMutation>();
    }
    else if (strcmp(opName, "CreditRouletteMultiOperator") == 0)
    {
        multiOperator = new CCreditRouletteMultiOperator<AMutation>();
    }
    else if (strcmp(opName, "InvCreditRouletteMultiOperator") == 0)
    {
        multiOperator = new CInvCreditRouletteMultiOperator<AMutation>();
    }
    
    if (multiOperator)
    {
        // TODO - we might think of better way of finding sub operators
        const std::string subMutationKey("SubMutation");
        int subOperatorIdx = 0;
        std::string nextSubMutationKey = subMutationKey + std::to_string(subOperatorIdx);
        while (configMap->HasValue(nextSubMutationKey))
        {
            if (AMutation* atomicOperator = CMutationFactory::Create(configMap, nextSubMutationKey, problem))
            {
                multiOperator->AddOperator(atomicOperator);
            }
            nextSubMutationKey = subMutationKey + std::to_string(++subOperatorIdx);
        }
    }

    return multiOperator;
}


optimizer\src\factories\method\operators\mutation\CMutationFactory.cpp
=============
#include <regex>
#include <cstring>
#include "CMutationFactory.h"
#include "method/operators/mutation/mutations/CRandomBit.h"
#include "method/operators/mutation/mutations/CTTPReverseFlip.h"
#include "method/operators/mutation/mutations/CCVRPReverseFlip.h"
#include "method/operators/mutation/mutations/CCheapestResourceMutation.h"
#include "method/operators/mutation/mutations/CLeastAssignedResourceMutation.h"
#include "utils/fileReader/CReadUtils.h"
#include "problem/problems/MSRCPSP/CMSRCPSP_TA.h"
#include "problem/problems/ECVRPTW/CECVRPTW.h"
#include "method/operators/mutation/mutations/ECVRPTW/CECVRPTWRandomClientRemoval.h"
#include "method/operators/mutation/mutations/ECVRPTW/CECVRPTWShawClientRemoval.h"
#include "method/operators/mutation/mutations/ECVRPTW/CECVRPTWShawClientInsertion.h"
#include "method/operators/mutation/mutations/ECVRPTW/CECVRPTWRandomClientInsertion.h"

AMutation *CMutationFactory::Create(SConfigMap *configMap, const std::string& configKey, AProblem &problem)
{
    std::string rawMutationString;
    if (!configMap->TakeValue(configKey, rawMutationString))
    {
        return nullptr;
    }

    auto const vec = CReadUtils::SplitLine(rawMutationString);
    const char *opName = vec[0].c_str();

    const std::set<EEncodingType> &encodingTypes = GetAllEncodingTypes(problem.GetProblemEncoding().m_Encoding);
    if (strcmp(opName, "RandomBit") == 0 && (encodingTypes.find(EEncodingType::ASSOCIATION) != encodingTypes.end() || encodingTypes.find(EEncodingType::PERMUTATION) != encodingTypes.end()))
    {
        float mutProb = std::stof(vec[1]);
        return new CRandomBit(mutProb);
    }
    else if (strcmp(opName, "TTP_Reverse_Flip") == 0 && encodingTypes.find(EEncodingType::PERMUTATION) != encodingTypes.end())
    {
        float mutProb = std::stof(vec[1]);
        float etaCoef = std::stof(vec[2]);
        return new CTTPReverseFlip(mutProb, etaCoef);
    }
    else if (strcmp(opName, "CVRP_Reverse_Flip") == 0 && encodingTypes.find(EEncodingType::PERMUTATION) != encodingTypes.end())
    {
        float mutProb = std::stof(vec[1]);
        return new CCVRPReverseFlip(mutProb);
    }
    else if (strcmp(opName, "CheapestResourceMutation") == 0)
    {
        float mutProb = std::stof(vec[1]);
        return new CCheapestResourceMutation(mutProb, dynamic_cast<CMSRCPSP_TA&>(problem));
    }
    else if (strcmp(opName, "LeastAssignedResourceMutation") == 0)
    {
        float mutProb = std::stof(vec[1]);
        return new CLeastAssignedResourceMutation(mutProb, dynamic_cast<CMSRCPSP_TA&>(problem));
    }
    // ECVRPTW
    else if (strcmp(opName, "ECVRPTW_RandomClientRemoval") == 0)
    {
        return new CECVRPTWRandomClientRemoval(dynamic_cast<CECVRPTW&>(problem));
    }
    else if (strcmp(opName, "ECVRPTW_ShawClientRemoval") == 0)
    {
        return new CECVRPTWShawClientRemoval(dynamic_cast<CECVRPTW&>(problem));
    }
    else if (strcmp(opName, "ECVRPTW_RandomClientInsertion") == 0)
    {
        return new CECVRPTWRandomClientInsertion(dynamic_cast<CECVRPTW&>(problem));
    }
    else if (strcmp(opName, "ECVRPTW_ShawClientInsertion") == 0)
    {
        return new CECVRPTWShawClientInsertion(dynamic_cast<CECVRPTW&>(problem));
    }
    return nullptr;
}

std::set<EEncodingType> CMutationFactory::GetAllEncodingTypes(const std::vector<SEncodingSection> &encoding)
{
    std::set<EEncodingType> uniqueTypes;

    for (const auto &section: encoding)
    {
        uniqueTypes.insert(section.m_SectionType);
    }

    return uniqueTypes;
}

optimizer\src\factories\method\operators\selection\CSelectionFactory.cpp
=============
#include <regex>
#include "CSelectionFactory.h"
#include "../../../../utils/fileReader/CReadUtils.h"

CFitnessTournament *CSelectionFactory::CreateFitnessTournamentSelection(SConfigMap *configMap)
{
    int tournamentSize = ValidateSelectionAndReturnTournamentSize(configMap, "FitnessTournament");
    return new CFitnessTournament(tournamentSize);
}

CRankedTournament *CSelectionFactory::CreateRankedTournamentSelection(SConfigMap *configMap)
{
    int tournamentSize = ValidateSelectionAndReturnTournamentSize(configMap, "RankedTournament");
    return new CRankedTournament(tournamentSize);
}

CGapSelectionByRandomDim *CSelectionFactory::CreateGapSelection(SConfigMap *configMap, bool bntga)
{
    int tournamentSize = ValidateSelectionAndReturnTournamentSize(configMap, "GapSelection");
    return new CGapSelectionByRandomDim(tournamentSize, bntga);
}

int CSelectionFactory::ValidateSelectionAndReturnTournamentSize(SConfigMap *configMap, std::string selectionName)
{
    std::string rawSelectionString;
    if (!configMap->TakeValue(selectionName, rawSelectionString))
    {
        throw std::runtime_error("Cannot find " + selectionName + " param in configuration");
    }
    auto const parameters = CReadUtils::SplitLine(rawSelectionString);

    if (parameters.empty())
    {
        throw std::runtime_error("Tournament size for " + selectionName + " not provided");
    }

    try
    {
        return std::stoi(parameters[0]);
    }
    catch (const std::invalid_argument &e)
    {
        throw std::runtime_error("Invalid tournament size");
    }
}


optimizer\src\factories\problem\CProblemFactory.cpp
=============

#include <cstring>
#include "CProblemFactory.h"
#include "MSRCPSP/CMSRCPSP_Factory.h"
#include "TTP/CTTPFactory.h"
#include "CVRP/CCVRPFactory.h"
#include "ECVRPTW/CECVRPTWFactory.h"
#include "TSP/CTSPFactory.h"

// Define the static method 'CreateProblem' in the 'CProblemFactory' class
// This method creates instances of different problem types based on the provided problem name
AProblem *CProblemFactory::CreateProblem(const char *problemName, const char *problemConfigurationPath)
{
    if (strcmp(problemName, "MSRCPSP_TA") == 0) return CMSRCPSP_Factory::CreateMSRCPSP_TA(problemConfigurationPath, 5);
    if (strcmp(problemName, "MSRCPSP_TA2") == 0) return CMSRCPSP_Factory::CreateMSRCPSP_TA(problemConfigurationPath, 2);
    if (strcmp(problemName, "MSRCPSP_TO") == 0) return CMSRCPSP_Factory::CreateMSRCPSP_TO(problemConfigurationPath, 5);
    if (strcmp(problemName, "MSRCPSP_TO2") == 0) return CMSRCPSP_Factory::CreateMSRCPSP_TO(problemConfigurationPath, 2);
    if (strcmp(problemName, "TSP") == 0) return CTSPFactory::CreateTSP(problemConfigurationPath);
    if (strcmp(problemName, "TTP1") == 0) return CTTPFactory::CreateTTP1(problemConfigurationPath);
    if (strcmp(problemName, "TTP2") == 0) return CTTPFactory::CreateTTP2(problemConfigurationPath);
    if (strcmp(problemName, "CVRP") == 0) return CCVRPFactory::CreateCVRP(problemConfigurationPath);
    if (strcmp(problemName, "ECVRPTW") == 0) return CECVRPTWFactory::CreateECVRPTW(problemConfigurationPath);

    // If none of the above conditions are met, throw a runtime error indicating the problem name is not supported
    throw std::runtime_error("Problem name: " + std::string(problemName) + " not supported");
}

// Define the static method 'DeleteObjects' in the 'CProblemFactory' class
// This method is responsible for cleaning up and deleting objects created by the factory
void CProblemFactory::DeleteObjects()
{
    // Call the DeleteObjects method of the CMSRCPSP_TA_Factory to clean up its objects
    CMSRCPSP_Factory::DeleteObjects();

    // Call the DeleteObjects method of the CTSPFactory to clean up its objects
    CTSPFactory::DeleteObjects();
    
    // Call the DeleteObjects method of the CTTPFactory to clean up its objects
    CTTPFactory::DeleteObjects();

    // Call the DeleteObjects method of the CCVRPFactory to clean up its objects
    CCVRPFactory::DeleteObjects();
}


optimizer\src\factories\problem\CVRP\CCVRPFactory.cpp
=============
#include "CCVRPFactory.h"
#include "utils/fileReader/CReadUtils.h"
#include <regex>

#define READ_CVRP 1

const std::string CCVRPFactory::s_Delimiter = ": ";
const std::string CCVRPFactory::s_DimensionKey = "DIMENSION :";
const std::string CCVRPFactory::s_CapacityKey = "CAPACITY :";
const std::string CCVRPFactory::s_CitiesSectionKey = "NODE_COORD_SECTION";
const std::string CCVRPFactory::s_DemandSectionKey = "DEMAND_SECTION";
const std::string CCVRPFactory::s_DepotSectionKey = "DEPOT_SECTION";

CCVRPTemplate *CCVRPFactory::cvrpTemplate = nullptr;

CCVRP *CCVRPFactory::CreateCVRP(const char *problemDefinitionPath) {
    cvrpTemplate = ReadCVRPTemplate(problemDefinitionPath);
    return new CCVRP(*cvrpTemplate);
}

void CCVRPFactory::DeleteObjects() {
    delete cvrpTemplate;
}

CCVRPTemplate *CCVRPFactory::ReadCVRPTemplate(const char *problemDefinitionPath) {
    auto *result = new CCVRPTemplate();

    std::ifstream readFileStream(problemDefinitionPath);

    int dimension = 0;
    if (!CReadUtils::GotoReadIntegerByKey(readFileStream, s_DimensionKey, s_Delimiter, dimension))
        throw std::runtime_error("Error reading dimension for CVRP");
#if READ_CVRP
    int capacity = 0;
    if (!CReadUtils::GotoReadIntegerByKey(readFileStream, s_CapacityKey, s_Delimiter, capacity))
        throw std::runtime_error("Error reading capacity for CVRP");
#endif

    std::vector<SCityCVRP> cities;
    ReadCitiesAndDemand(readFileStream, dimension, cities);

    std::vector<size_t> depotIndexes;
    ReadDepot(readFileStream, depotIndexes);

    int trucks = 1;
    std::string pathString(problemDefinitionPath);
    size_t fileNameStartPos = pathString.rfind("/") + 1;
    size_t fileNameEndPos = pathString.rfind(".");
    result->SetFileName(pathString.substr(fileNameStartPos, fileNameEndPos - fileNameStartPos));
#if READ_CVRP
    result->SetData(cities, capacity, trucks, depotIndexes);
#endif

    readFileStream.close();
    return result;
}

void CCVRPFactory::ReadCitiesAndDemand(std::ifstream &fileStream, int dimension, std::vector<SCityCVRP> &cities) {
    std::string line;
    std::vector<float> x;
    std::vector<float> y;
    std::vector<int> demand;

    if (CReadUtils::GotoLineByKey(fileStream, s_CitiesSectionKey, line)) {
        for (int i = 0; i < dimension; ++i) {
            if (std::getline(fileStream, line)) {
                auto const vec = CReadUtils::SplitLine(line);
                x.emplace_back(std::stof(vec[2]));
                y.emplace_back(std::stof(vec[3]));
            }
        }
    }

    if (CReadUtils::GotoLineByKey(fileStream, s_DemandSectionKey, line)) {
        for (int i = 0; i < dimension; ++i) {
            if (std::getline(fileStream, line)) {
                auto const vec = CReadUtils::SplitLine(line);
                cities.emplace_back(std::stoi(vec[0]), x[i], y[i], std::stoi(vec[1]));
            }
        }
    }
}

void CCVRPFactory::ReadDepot(std::ifstream &fileStream, std::vector<size_t> &depotIndexes) {
    std::string line;

    if (CReadUtils::GotoLineByKey(fileStream, s_DepotSectionKey, line)) {
        while(true) {
            if (std::getline(fileStream, line)) {
                int index = std::stoi(line);
                if (index == -1)
                    break;
                depotIndexes.emplace_back(index);
            }
        }
    }
}


optimizer\src\factories\problem\ECVRPTW\CECVRPTWFactory.cpp
=============
#include "CECVRPTWFactory.h"
#include "utils/fileReader/CReadUtils.h"
#include <regex>
#include <iostream>


const std::string CECVRPTWFactory::s_Delimiter = ": ";
const std::string CECVRPTWFactory::s_CapacityKey = "C";
const std::string CECVRPTWFactory::s_TankCapacityKey = "Q";
const std::string CECVRPTWFactory::s_FuelConsumptionKey = "r";
const std::string CECVRPTWFactory::s_InverseRefuelingRateKey = "g";
const std::string CECVRPTWFactory::s_VelocityKey = "v";
const std::string CECVRPTWFactory::s_VehicleCountKey = "n";
const std::string CECVRPTWFactory::s_CitiesSectionKey = "StringID";

CECVRPTWTemplate* CECVRPTWFactory::cvrpTemplate = nullptr;

CECVRPTW* CECVRPTWFactory::CreateECVRPTW(const char* problemDefinitionPath) {
    cvrpTemplate = ReadECVRPTWTemplate(problemDefinitionPath);
    return new CECVRPTW(*cvrpTemplate);
}

void CECVRPTWFactory::DeleteObjects() {
    delete cvrpTemplate;
}

CECVRPTWTemplate* CECVRPTWFactory::ReadECVRPTWTemplate(const char* problemDefinitionPath) {
    auto* result = new CECVRPTWTemplate();

    std::ifstream readFileStream(problemDefinitionPath);

    int dimension = 0;
    std::vector<SCityECVRPTW> cities;
    ReadCities(readFileStream, dimension, cities);

    auto const regex = std::regex{ "[0-9]+[.][0-9]+" };

    float fuelTankCapacity = 0;
    if (!CReadUtils::GoToReadFloatByKeyAndRegex(readFileStream, s_TankCapacityKey, regex, fuelTankCapacity))
        throw std::runtime_error("Error reading tank capacity for CVRP");

    float capacity = 0;
    if (!CReadUtils::GoToReadFloatByKeyAndRegex(readFileStream, s_CapacityKey, regex, capacity))
        throw std::runtime_error("Error reading capacity for CVRP");

    float fuelConsumptionRate = 0;
    if (!CReadUtils::GoToReadFloatByKeyAndRegex(readFileStream, s_FuelConsumptionKey, regex, fuelConsumptionRate))
        throw std::runtime_error("Error reading fuel consumption rate for CVRP");

    float inverseRefuelingRate = 0;
    if (!CReadUtils::GoToReadFloatByKeyAndRegex(readFileStream, s_InverseRefuelingRateKey, regex, inverseRefuelingRate))
        throw std::runtime_error("Error reading refueling rate for CVRP");

    float velocity = 0;
    if (!CReadUtils::GoToReadFloatByKeyAndRegex(readFileStream, s_VelocityKey, regex, velocity))
        throw std::runtime_error("Error reading velocity for CVRP");

    float vehicleCount = 0;
    if (!CReadUtils::GoToReadFloatByKeyAndRegex(readFileStream, s_VehicleCountKey, regex, vehicleCount))
        throw std::runtime_error("Error reading velocity for CVRP");

    readFileStream.close();

    std::vector<size_t> depotIndexes;
    std::vector<size_t> chargingStationIndexes;
    std::vector<size_t> customerIndexes;

    for (int i = 0; i < cities.size(); i++)
    {
        switch (cities[i].m_Type)
        {
            case ENodeType::Depot:
                depotIndexes.emplace_back(i);
                chargingStationIndexes.emplace_back(i);
                break;
            case ENodeType::ChargingStation:
                chargingStationIndexes.emplace_back(i);
                break;
            case ENodeType::Customer:
                customerIndexes.emplace_back(i);
                break;
        }
    }

    std::string pathString(problemDefinitionPath);
    size_t fileNameStartPos = pathString.rfind("/") + 1;
    size_t fileNameEndPos = pathString.rfind(".");
    result->SetFileName(pathString.substr(fileNameStartPos, fileNameEndPos - fileNameStartPos));
    result->SetData(cities,
                    capacity,
                    fuelTankCapacity,
                    fuelConsumptionRate,
                    inverseRefuelingRate,
                    velocity,
                    chargingStationIndexes,
                    depotIndexes,
                    customerIndexes,
                    (int)vehicleCount
    );

    if (!result->Validate())
    {
        throw std::runtime_error("Instance is invalid: " + std::string(problemDefinitionPath));
    }

    return result;
}

void CECVRPTWFactory::ReadCities(std::ifstream& fileStream, int& dimension, std::vector<SCityECVRPTW>& cities) {
    std::string line;

    if (CReadUtils::GotoLineByKey(fileStream, s_CitiesSectionKey, line))
    {
        dimension = 0;
        while (std::getline(fileStream, line) && !line.empty())
        {
            auto const re = std::regex{ R"(\s+)" };
            auto const vec = std::vector<std::string>(std::sregex_token_iterator{ line.begin(), line.end(), re, -1 }, std::sregex_token_iterator{});
            cities.emplace_back(dimension++,
                                vec[0],
                                (ENodeType)vec[1][0],
                                std::stof(vec[2]),
                                std::stof(vec[3]),
                                (int)std::stof(vec[4]),
                                std::stof(vec[5]),
                                std::stof(vec[6]),
                                std::stof(vec[7])
            );
        }
    }
    else
    {
        throw std::runtime_error("Error reading cities for ECVRPTW");
    }
}

optimizer\src\factories\problem\MSRCPSP\CMSRCPSP_Factory.cpp
=============

#include "utils/fileReader/CReadUtils.h"
#include <fstream>
#include "CMSRCPSP_Factory.h"

const std::string CMSRCPSP_Factory::s_Delimiter = " ";
const std::string CMSRCPSP_Factory::s_TasksKey = "Tasks:";
const std::string CMSRCPSP_Factory::s_ResourcesKey = "Resources:";
const std::string CMSRCPSP_Factory::s_ResourcesSectionKey = "ResourceID";
const std::string CMSRCPSP_Factory::s_TasksSectionKey = "TaskID";

CScheduler *CMSRCPSP_Factory::scheduler = nullptr;

CMSRCPSP_TA *CMSRCPSP_Factory::CreateMSRCPSP_TA(const char *problemConfigurationPath, size_t objCount)
{
    scheduler = CreateScheduler(problemConfigurationPath);

    return new CMSRCPSP_TA(*scheduler, objCount);
}

CMSRCPSP_TO* CMSRCPSP_Factory::CreateMSRCPSP_TO(const char* problemConfigurationPath, size_t objCount)
{
    scheduler = CreateScheduler(problemConfigurationPath);

    return new CMSRCPSP_TO(*scheduler, objCount);
}

void CMSRCPSP_Factory::DeleteObjects()
{
    delete scheduler;
}

CScheduler *CMSRCPSP_Factory::CreateScheduler(const char *problemConfigurationPath)
{
    scheduler = new CScheduler();

    std::ifstream readFileStream(problemConfigurationPath);
    
    std::string instanceName;
    if (!CReadUtils::GotoReadStringByKey(readFileStream, "File name:", s_Delimiter, instanceName))
    {
        throw std::runtime_error("Error reading instance name for MSRCPSP");
    }
    scheduler->SetInstanceName(instanceName);
    
    int tasksNumber = 0;
    if (!CReadUtils::GotoReadIntegerByKey(readFileStream, s_TasksKey, s_Delimiter, tasksNumber))
    {
        throw std::runtime_error("Error reading task number for MSRCPSP");
    }

    int resourcesNumber = 0;
    if (!CReadUtils::GotoReadIntegerByKey(readFileStream, s_ResourcesKey, s_Delimiter, resourcesNumber))
    {
        throw std::runtime_error("Error reading resource number for MSRCPSP");
    }

    std::vector<CResource> resources;
    ReadResources(readFileStream, resourcesNumber, resources);
    std::vector<CTask> tasks;
    ReadTasks(readFileStream, tasksNumber, tasks);

    readFileStream.close();

    for (const CTask &task: tasks)
    {
        for (TTaskID predecessorTaskId: task.GetPredecessors())
        {
            tasks[(size_t) predecessorTaskId - 1].SetHasSuccessors(true);
        }
    }

    scheduler->SetResources(resources);
    scheduler->SetTasks(tasks);
    scheduler->Reset();

    return scheduler;
}

void CMSRCPSP_Factory::ReadResources(std::basic_ifstream<char>& fileStream, int resourcesNumber, std::vector<CResource>& resources)
{
    std::string line;
    if (!CReadUtils::GotoLineByKey(fileStream, s_ResourcesSectionKey, line))
    {
        throw std::runtime_error("Error reading resources for MSRCPSP");
    }

    for (int i = 0; i < resourcesNumber; ++i)
    {
        if (std::getline(fileStream, line))
        {
            auto const vec = CReadUtils::SplitLine(line);

            std::vector<SSkill> skills;
            for (size_t i = 2; i + 1 < vec.size(); i += 2)
            {
                skills.emplace_back(std::stoi(vec[i].substr(1, vec[i].length() - 1)), std::stoi(vec[i + 1]));
            }
            resources.emplace_back(std::stoi(vec[0]), std::stof(vec[1]), skills);
        }
    }
}

void CMSRCPSP_Factory::ReadTasks(std::basic_ifstream<char>& fileStream, int tasksNumber, std::vector<CTask>& tasks)
{
    std::string line;
    if (!CReadUtils::GotoLineByKey(fileStream, s_TasksSectionKey, line))
    {
        throw std::runtime_error("Error reading tasks for MSRCPSP");
    }

    for (int i = 0; i < tasksNumber; ++i)
    {
        if (std::getline(fileStream, line))
        {
            auto const vec = CReadUtils::SplitLine(line);

            size_t tokenIndex = 2;
            std::vector<SSkill> skills;
            while (tokenIndex + 1 < vec.size() && vec[tokenIndex].substr(0, 1) == "Q")
            {
                skills.emplace_back(std::stoi(vec[tokenIndex].substr(1, vec[tokenIndex].length() - 1)),
                    std::stoi(vec[tokenIndex + 1]));
                tokenIndex += 2;
            }

            std::vector<TTaskID> predecessors;
            while (tokenIndex < vec.size())
            {
                predecessors.push_back(std::stoi(vec[tokenIndex]));
                ++tokenIndex;
            }
            tasks.emplace_back(std::stoi(vec[0]), skills, std::stoi(vec[1]), predecessors);
        }
    }
}

optimizer\src\factories\problem\TSP\CTSPFactory.cpp
=============
#include "CTSPFactory.h"

const std::string CTSPFactory::s_Delimiter = " ";
const std::string CTSPFactory::s_DimensionKey = "DIMENSION:";
const std::string CTSPFactory::s_CitiesSectionKey = "NODE_COORD_SECTION";

CTSPTemplate *CTSPFactory::tspTemplate = nullptr;

optimizer\src\factories\problem\TTP\CTTPFactory.cpp
=============
#include "CTTPFactory.h"
#include "utils/fileReader/CReadUtils.h"
#include <string>
#include <vector>

#define READ_TTP 1

const std::string CTTPFactory::s_Delimiter = "\t";
const std::string CTTPFactory::s_DimensionKey = "DIMENSION:";
const std::string CTTPFactory::s_ItemsCountKey = "NUMBER OF ITEMS:";
const std::string CTTPFactory::s_CapacityKey = "CAPACITY OF KNAPSACK:";
const std::string CTTPFactory::s_MinSpeedKey = "MIN SPEED:";
const std::string CTTPFactory::s_MaxSpeedKey = "MAX SPEED:";
const std::string CTTPFactory::s_RentingRatioKey = "RENTING RATIO:";
const std::string CTTPFactory::s_CitiesSectionKey = "NODE_COORD_SECTION	(INDEX, X, Y):";
const std::string CTTPFactory::s_ItemsSectionKey = "ITEMS SECTION	(INDEX, PROFIT, WEIGHT, ASSIGNED NODE NUMBER):";

CTTPTemplate *CTTPFactory::ttpTemplate = nullptr;

CTTP1 *CTTPFactory::CreateTTP1(const char *problemDefinitionPath)
{
    CTTP2 *ttp2 = CreateTTP2(problemDefinitionPath);
    return new CTTP1(*ttp2);
}

CTTP2 *CTTPFactory::CreateTTP2(const char *problemDefinitionPath)
{
    ttpTemplate = ReadTTPTemplate(problemDefinitionPath);
    return new CTTP2(*ttpTemplate);
}

void CTTPFactory::DeleteObjects()
{
    delete ttpTemplate;
}

CTTPTemplate *CTTPFactory::ReadTTPTemplate(const char *problemDefinitionPath)
{
    auto *result = new CTTPTemplate();

    std::ifstream readFileStream(problemDefinitionPath);

    int dim = 0;
    if (!CReadUtils::GotoReadIntegerByKey(readFileStream, s_DimensionKey, s_Delimiter, dim))
    {
        throw std::runtime_error("Error reading dim (dimensions) for TTP");
    }
#if READ_TTP
    int itemCount = 0;
    if (!CReadUtils::GotoReadIntegerByKey(readFileStream, s_ItemsCountKey, s_Delimiter, itemCount))
    {
        throw std::runtime_error("Error reading itemCount for TTP");
    }
    int capacity = 0;
    if (!CReadUtils::GotoReadIntegerByKey(readFileStream, s_CapacityKey, s_Delimiter, capacity))
    {
        throw std::runtime_error("Error reading capacity for TTP");
    }

    float minSpeed = 0.f;
    if (!CReadUtils::GotoReadFloatByKey(readFileStream, s_MinSpeedKey, s_Delimiter, minSpeed))
    {
        throw std::runtime_error("Error reading minSpeed for TTP");
    }
    float maxSpeed = 0.f;
    if (!CReadUtils::GotoReadFloatByKey(readFileStream, s_MaxSpeedKey, s_Delimiter, maxSpeed))
    {
        throw std::runtime_error("Error reading maxSpeed for TTP");
    }
    float rentRatio = 0.f;
    if (!CReadUtils::GotoReadFloatByKey(readFileStream, s_RentingRatioKey, s_Delimiter, rentRatio))
    {
        throw std::runtime_error("Error reading rentRatio for TTP");
    }
#endif

    std::vector<SCity> cities;
    ReadCities(readFileStream, dim, cities);

    std::vector<SItem> items;
#if READ_TTP
    ReadItems(readFileStream, itemCount, items);
#endif

#if USE_EOK
    // Add extra EOK flag item
    items.emplace_back(0, 0, 0, 0);
#endif

    std::string pathString(problemDefinitionPath);
    size_t fileNameStartPos = pathString.rfind('/') + 1;
    size_t fileNameEndPos = pathString.rfind('.');
    result->SetFileName(pathString.substr(fileNameStartPos, fileNameEndPos - fileNameStartPos));
#if READ_TTP
    result->SetData(cities, items, capacity, minSpeed, maxSpeed, rentRatio);
#else
    ttp.SetData(cities, items, 0, 0, 1, 1);
#endif

    readFileStream.close();

    return result;
}

void CTTPFactory::ReadCities(std::ifstream &fileStream, int dimension, std::vector<SCity> &cities)
{
    std::string line;
    if (!CReadUtils::GotoLineByKey(fileStream, s_CitiesSectionKey, line))
    {
        throw std::runtime_error("Error reading cities for TTP");
    }

    for (int i = 0; i < dimension; ++i)
    {
        if (std::getline(fileStream, line))
        {
            const std::vector<std::string> vec = CReadUtils::SplitLine(line);
            cities.emplace_back(std::stoi(vec[0]), std::stof(vec[1]), std::stof(vec[2]));
        }
    }
}

void CTTPFactory::ReadItems(std::ifstream &fileStream, int itemCount, std::vector<SItem> &items)
{
    std::string line;
    if (!CReadUtils::GotoLineByKey(fileStream, s_ItemsSectionKey, line))
    {
        throw std::runtime_error("Error reading items for TTP");
    }

    for (int i = 0; i < itemCount; ++i)
    {
        if (std::getline(fileStream, line))
        {
            const std::vector<std::string> vec = CReadUtils::SplitLine(line);
            items.emplace_back(std::stoi(vec[0]), std::stoi(vec[1]), std::stoi(vec[2]), std::stoi(vec[3]));
        }
    }
}


optimizer\src\method\configMap\SConfigMap.cpp
=============


#include "SConfigMap.h"

bool SConfigMap::AddLine(const std::string &keyString, const std::string &valueString)
{
    if (m_ConfigMap.find(keyString) != m_ConfigMap.end())
    {
        return false;
    }
    m_ConfigMap.insert(std::pair<std::string, std::string>(keyString, valueString));
    return true;
}

bool SConfigMap::HasValue(const std::string &paramKey)
{
    const auto &it = m_ConfigMap.find(paramKey);
    return it != m_ConfigMap.end();
}

bool SConfigMap::TakeValue(const std::string &paramKey, int &outValue)
{
    const auto &it = m_ConfigMap.find(paramKey);
    if (it != m_ConfigMap.end())
    {
        outValue = std::stoi(it->second);
        m_ConfigMap.erase(it);
        return true;
    }
    return false;
}

bool SConfigMap::TakeValue(const std::string &paramKey, size_t &outValue)
{
    const auto &it = m_ConfigMap.find(paramKey);
    if (it != m_ConfigMap.end())
    {
        outValue = std::stoull(it->second);
        m_ConfigMap.erase(it);
        return true;
    }
    return false;
}

bool SConfigMap::TakeValue(const std::string &paramKey, float &outValue)
{
    const auto &it = m_ConfigMap.find(paramKey);
    if (it != m_ConfigMap.end())
    {
        outValue = std::stof(it->second);
        m_ConfigMap.erase(it);
        return true;
    }
    return false;
}

bool SConfigMap::TakeValue(const std::string &paramKey, double &outValue)
{
    const auto &it = m_ConfigMap.find(paramKey);
    if (it != m_ConfigMap.end())
    {
        outValue = std::stod(it->second);
        m_ConfigMap.erase(it);
        return true;
    }
    return false;
}

bool SConfigMap::TakeValue(const std::string &paramKey, std::string &outValue)
{
    const auto &it = m_ConfigMap.find(paramKey);
    if (it != m_ConfigMap.end())
    {
        outValue = it->second;
        m_ConfigMap.erase(it);
        return true;
    }
    return false;
}

void SConfigMap::Clear()
{
    m_ConfigMap.clear();
}


optimizer\src\method\methods\MO\ANTGA\CANTGA.cpp
=============
#include <algorithm>
#include <sstream>
#include "CANTGA.h"
#include "method/methods/MO/utils/archive/ArchiveUtils.h"
#include "utils/logger/ErrorUtils.h"
#include "factories/method/operators/mutation/CMultiMutationFactory.h"
#include "factories/method/CMethodFactory.h"
#include "utils/dataStructures/CCSV.h"
#include "utils/logger/CExperimentLogger.h"

CANTGA::CANTGA(AProblem& evaluator, AInitialization& initialization,
               ACrossover& crossover, AMutation& mutation, CGapSelectionByRandomDim& gapSelection,
               SConfigMap* configMap)
    : AMOGeneticMethod(evaluator, initialization, crossover, mutation), m_GapSelection(gapSelection)
{
    configMap->TakeValue("PopulationSize", m_PopulationSize);
    ErrorUtils::LowerThanZeroI("ANTGA", "PopulationSize", m_PopulationSize);
    m_Population.reserve(m_PopulationSize);
    m_NextPopulation.reserve(m_PopulationSize);

    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    ErrorUtils::LowerThanZeroI("ANTGA", "GenerationLimit", m_GenerationLimit);

    m_MultiMutation = CMultiMutationFactory::Create(configMap, evaluator);
}

CANTGA::~CANTGA()
{
    if (m_MultiMutation)
    {
        delete m_MultiMutation;
    }
}

void CANTGA::RunOptimization()
{
    m_Generation = 0;

    CCSV<float> m_PopulationHistory(1 + m_Problem.GetProblemEncoding().m_objectivesNumber + 5);
    CCSV<float> m_ArchiveHistory(1 + m_Problem.GetProblemEncoding().m_objectivesNumber + 5);

    for (size_t i = 0; i < m_PopulationSize; ++i)
    {
        SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
        auto* newInd = m_Initialization.CreateMOIndividual(problemEncoding);
        m_Problem.Evaluate(*newInd);
        m_Population.push_back(newInd);
    }

    ArchiveUtils::CopyToArchiveWithFiltering(m_Population, m_Archive);

    while (m_Generation < m_GenerationLimit)
    {
        EvolveToNextGeneration();

        LogIndividualsToCSV(m_PopulationHistory, m_NextPopulation);
        LogIndividualsToCSV(m_ArchiveHistory, m_Archive);

        for (SMOIndividual* ind: m_Population)
        {
            delete ind;
        }
        m_Population = m_NextPopulation;
        m_NextPopulation.clear();
        m_NextPopulation.reserve(m_Population.size());
        m_Generation++;
    }

    ArchiveUtils::LogParetoFront(m_Archive);
    CExperimentLogger::LogResult(m_PopulationHistory.ToStringStream().str().c_str(), "PopHist.csv");
    CExperimentLogger::LogResult(m_ArchiveHistory.ToStringStream().str().c_str(), "ArchHist.csv");
}

void CANTGA::Reset()
{
    AMOGeneticMethod::Reset();
    m_Generation = 0;
    m_MultiMutation->ResetAllOperatorData();
}

void CANTGA::EvolveToNextGeneration()
{
    const auto& parents = m_GapSelection.Select(
        m_Archive,
        m_Problem.GetProblemEncoding().m_objectivesNumber,
        m_PopulationSize
    );
    for (auto& parentPair : parents)
    {
        CrossoverAndMutate(parentPair.first, parentPair.second);
    }
    ArchiveUtils::CopyToArchiveWithFiltering(m_NextPopulation, m_Archive);
}

void CANTGA::CrossoverAndMutate(SMOIndividual* firstParent, SMOIndividual* secondParent)
{
    auto* firstChild = new SMOIndividual{*firstParent};
    auto* secondChild = new SMOIndividual{*secondParent};

    m_Crossover.Crossover(
        m_Problem.GetProblemEncoding(),
        *firstParent,
        *secondParent,
        *firstChild,
        *secondChild
    );

    CAtomicOperator<AMutation>* atomicMutation = m_MultiMutation->SelectOperator();
    AMutation* mutation = atomicMutation->Get();
    mutation->Mutate(m_Problem.GetProblemEncoding(), *firstChild);
    mutation->Mutate(m_Problem.GetProblemEncoding(), *secondChild);
    // TODO - update mutation with feedback

    size_t operatorId = atomicMutation->GetId();
    secondChild->m_MetaInfo = firstChild->m_MetaInfo = {
        (float)operatorId,
        firstParent->m_Evaluation[0], firstParent->m_Evaluation[1],
        secondParent->m_Evaluation[0], secondParent->m_Evaluation[1]
    };

    m_Problem.Evaluate(*firstChild);
    m_Problem.Evaluate(*secondChild);

    m_NextPopulation.emplace_back(firstChild);
    m_NextPopulation.emplace_back(secondChild);
}

void CANTGA::LogIndividualsToCSV(CCSV<float>& csv, const std::vector<SMOIndividual*>& individuals) const
{
    for (const auto& ind : individuals)
    {
        std::vector<float> newRow = { (float)m_Generation };
        newRow.insert(newRow.end(), ind->m_Evaluation.begin(), ind->m_Evaluation.end());
        newRow.insert(newRow.end(), ind->m_MetaInfo.begin(), ind->m_MetaInfo.end());
        csv.AddRow(std::move(newRow));
    }
}

optimizer\src\method\methods\MO\BNTGA\CBNTGA.cpp
=============
#include <algorithm>
#include <sstream>
#include "CBNTGA.h"
#include "../utils/archive/ArchiveUtils.h"
#include "../../../../utils/logger/ErrorUtils.h"

CBNTGA::CBNTGA(AProblem &evaluator, AInitialization &initialization,
               ACrossover &crossover, AMutation &mutation, CGapSelectionByRandomDim& gapSelection, SConfigMap *configMap) :
        AMOGeneticMethod(evaluator, initialization, crossover, mutation), m_GapSelection(gapSelection)
{
    configMap->TakeValue("PopulationSize", m_PopulationSize);
    ErrorUtils::LowerThanZeroI("BNTGA", "PopulationSize", m_PopulationSize);
    m_Population.reserve(m_PopulationSize);
    m_NextPopulation.reserve(m_PopulationSize);

    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    ErrorUtils::LowerThanZeroI("BNTGA", "GenerationLimit", m_GenerationLimit);
}


void CBNTGA::RunOptimization()
{
    int generation = 0;

    for (size_t i = 0; i < m_PopulationSize; ++i)
    {
        SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
        auto* newInd = m_Initialization.CreateMOIndividual(problemEncoding);

        m_Problem.Evaluate(*newInd);

        m_Population.push_back(newInd);
    }

    ArchiveUtils::CopyToArchiveWithFiltering(m_Population, m_Archive);

    while (generation < m_GenerationLimit)
    {
        EvolveToNextGeneration();

        for (SMOIndividual* ind : m_Population)
        {
            delete ind;
        }
        m_Population = m_NextPopulation;
        m_NextPopulation.clear();
        m_NextPopulation.reserve(m_Population.size());

        generation++;
    }
    
    ArchiveUtils::LogParetoFront(m_Archive);
}

void CBNTGA::EvolveToNextGeneration()
{
    const auto &parents = m_GapSelection.Select(
            m_Archive,
            m_Problem.GetProblemEncoding().m_objectivesNumber,
            m_PopulationSize
    );
    for (auto& parentPair : parents)
    {
        CrossoverAndMutate(parentPair.first, parentPair.second);
    }
    ArchiveUtils::CopyToArchiveWithFiltering(m_NextPopulation, m_Archive);
}

void CBNTGA::CrossoverAndMutate(SMOIndividual* firstParent, SMOIndividual* secondParent)
{
    auto *firstChild = new SMOIndividual{*firstParent};
    auto *secondChild = new SMOIndividual{*secondParent};

    m_Crossover.Crossover(
            m_Problem.GetProblemEncoding(),
            *firstParent,
            *secondParent,
            *firstChild,
            *secondChild
    );

    m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *firstChild);
    m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *secondChild);

    m_Problem.Evaluate(*firstChild);
    m_Problem.Evaluate(*secondChild);

    m_NextPopulation.emplace_back(firstChild);
    m_NextPopulation.emplace_back(secondChild);
}


optimizer\src\method\methods\MO\MOEAD\CMOEAD.cpp
=============
#include <algorithm>
#include <sstream>
#include "CMOEAD.h"
#include "../utils/archive/ArchiveUtils.h"
#include "../utils/DasDennis/CDasDennis.h"
#include "../../../../utils/random/CRandom.h"
#include "../../../../utils/logger/ErrorUtils.h"

CMOEAD::CMOEAD(AProblem &problem, AInitialization &initialization, ACrossover &crossover, AMutation &mutation, SConfigMap *configMap)
        : AMOGeneticMethod(problem, initialization, crossover, mutation)
{
    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    ErrorUtils::LowerThanZeroI("CMOEAD", "GenerationLimit", m_GenerationLimit);

    configMap->TakeValue("PartitionsNumber", m_PartitionsNumber);
    ErrorUtils::LowerThanZeroI("CMOEAD", "PartitionsNumber", m_PartitionsNumber);

    configMap->TakeValue("NeighbourhoodSize", m_NeighbourhoodSize);
    ErrorUtils::LowerThanZeroI("CMOEAD", "NeighbourhoodSize", m_NeighbourhoodSize);
}


void CMOEAD::RunOptimization()
{
    int generation = 0;
    
    ConstructSubproblems(m_PartitionsNumber, m_NeighbourhoodSize);
    m_PopulationSize = m_Subproblems.size();
    m_Population.reserve(m_PopulationSize);

    for (size_t i = 0; i < m_PopulationSize; ++i)
    {
        SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
        auto* newInd = m_Initialization.CreateMOIndividual(problemEncoding);

        m_Problem.Evaluate(*newInd);

        m_Population.push_back(newInd);
    }
    
    ArchiveUtils::CopyToArchiveWithFiltering(m_Population, m_Archive);

    while ( generation < m_GenerationLimit)
    {
        EvolveToNextGeneration();
        generation++;
    }

    ArchiveUtils::LogParetoFront(m_Archive);
}

void CMOEAD::ConstructSubproblems(size_t partitionsNumber, size_t neighborhoodSize)
{
    size_t dimCount = m_Problem.GetProblemEncoding().m_objectivesNumber;

    if (dimCount == 2)
    {
        ConstructSubproblemsSimple2D(partitionsNumber, neighborhoodSize);
    }
    else
    {
        ConstructSubproblemsMultiD(partitionsNumber, neighborhoodSize, dimCount);
    }
}

void CMOEAD::ConstructSubproblemsSimple2D(size_t partitionsNumber, size_t neighborhoodSize)
{
    m_Subproblems.clear();

    // Simple impl for 2dim problems only
    float stepVal = 1.f / (partitionsNumber - 1);
    for (size_t i = 0; i < partitionsNumber; ++i)
    {
        m_Subproblems.emplace_back();
        SSubproblem& sp = m_Subproblems.back();
        sp.m_WeightVector = { 0.f + i * stepVal, 1.f - i * stepVal};
    }

    // For 2 dim, we assume they are ordered
    for (size_t i = 0; i < partitionsNumber; ++i)
    {
        int leftIdx = (int)i - ((int)neighborhoodSize / 2);
        if (leftIdx < 0) leftIdx = 0;
        size_t rightIdx = leftIdx + neighborhoodSize;
        if (rightIdx >= partitionsNumber)
        {
            // We assume that neighborhood is always smaller than subproblems size
            size_t excees = rightIdx - partitionsNumber;
            leftIdx -= excees;
            rightIdx -= excees;
        }
        for (size_t j = leftIdx; j < rightIdx; ++j)
        {
            m_Subproblems[i].m_Neighborhood.push_back(j);
        }
    }
}

void CMOEAD::ConstructSubproblemsMultiD(size_t partitionsNumber, size_t neighborhoodSize, size_t dimCount)
{
    m_Subproblems.clear();

    // Generate subproblems
    DasDennis ddGenerator(partitionsNumber, dimCount);
    size_t subVecCount = ddGenerator.GetPointsNumber();
    ddGenerator.GeneratePoints();
    std::vector<std::vector<float>> subproblemVectors = ddGenerator.GetPoints();

    for (const auto& subVec : subproblemVectors)
    {
        m_Subproblems.emplace_back();
        SSubproblem& sp = m_Subproblems.back();
        sp.m_WeightVector = std::vector<float>(dimCount, 0.f);
        for (size_t j = 0; j < dimCount; ++j)
        {
            sp.m_WeightVector[j] = subVec[j];
        }
    }

    // Calculate distances
    using TNeighborhood = std::vector<std::pair<size_t, float>>;
    std::vector<TNeighborhood> neighborhood = std::vector<TNeighborhood>(subVecCount, TNeighborhood(subVecCount));
    for (size_t i = 0; i < subVecCount; ++i)
    {
        auto& weightVectorI = m_Subproblems[i].m_WeightVector;
        size_t entryIdx = 0;
        for (size_t j = 0; j < subVecCount; ++j)
        {
            auto& weightVectorJ = m_Subproblems[j].m_WeightVector;
            std::pair<size_t, float>& entry = neighborhood[i][entryIdx];
            entry.first = j;

            float dist = 0.f;
            if (i != j)
            {
                for (size_t d = 0; d < dimCount; ++d)
                {
                    dist += powf(weightVectorI[d] - weightVectorJ[d], 2);
                }
                dist = sqrtf(dist);
            }
            entry.second = dist;
            ++entryIdx;
        }
    }

    // Link neighborhood
    for (TNeighborhood& nh : neighborhood)
    {
        // Sort ascending by distance, including distance to self
        std::sort(nh.begin(), nh.end(), [](const std::pair<size_t, float>& a, const std::pair<size_t, float>& b) -> bool
        {
            return a.second < b.second;
        });
    }

    for (size_t i = 0; i < subVecCount; ++i)
    {
        for (size_t j = 0; j < neighborhoodSize; ++j)
        {
            m_Subproblems[i].m_Neighborhood.push_back(neighborhood[i][j].first);
        }
    }
}

void CMOEAD::EvolveToNextGeneration()
{
// Temp individual used for testing new child genes
    SMOIndividual* testIndividual = nullptr;

    for (size_t i = 0; i < m_Population.size(); ++i)
    {
        const SSubproblem& sp = m_Subproblems[i];
        const size_t nhSize = sp.m_Neighborhood.size();
        
        size_t firstParentIdx = sp.m_Neighborhood[CRandom::GetInt(0, nhSize)];
        size_t secondParentIdx = sp.m_Neighborhood[CRandom::GetInt(0,nhSize)];
        SMOIndividual* firstParent = m_Population[firstParentIdx];
        SMOIndividual* secondParent = m_Population[secondParentIdx];

        auto *firstChild = new SMOIndividual{*firstParent};
        auto *secondChild = new SMOIndividual{*secondParent};

        m_Crossover.Crossover(
                m_Problem.GetProblemEncoding(),
                *firstParent,
                *secondParent,
                *firstChild,
                *secondChild
        );

        m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *firstChild);
        m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *secondChild);

        //Take only one child
        testIndividual = firstChild;
        m_Problem.Evaluate(*testIndividual);
        delete secondChild;

        // Now check if any neighborhood solution is improved
        for (size_t j : sp.m_Neighborhood)
        {
            if (IsBetterInSubproblem(testIndividual, m_Population[j], m_Subproblems[j]))
            {
                // I assume we can just copy whole individual
                *m_Population[j] = *testIndividual;
            }
        }

        ArchiveUtils::CopyToArchiveWithFiltering(testIndividual, m_Archive);
    }
}

bool CMOEAD::IsBetterInSubproblem(SMOIndividual *newIndividual, SMOIndividual *&oldIndividual, CMOEAD::SSubproblem &subproblem)
{
    // Simple weighted sum
    float newValue = 0.f;
    float oldValue = 0.f;
    const size_t objCount = m_Problem.GetProblemEncoding().m_objectivesNumber;
    for (size_t i = 0; i < objCount; ++i)
    {
        newValue += newIndividual->m_NormalizedEvaluation[i] * subproblem.m_WeightVector[i];
        oldValue += oldIndividual->m_NormalizedEvaluation[i] * subproblem.m_WeightVector[i];
    }
    // Minimization
    return newValue < oldValue;
}



optimizer\src\method\methods\MO\NSGAII\CNSGAII.cpp
=============
#include <cfloat>
#include <algorithm>
#include <sstream>
#include "CNSGAII.h"
#include "../utils/archive/ArchiveUtils.h"
#include "../utils/clustering/CNonDominatedSorting.h"
#include "../../../../utils/logger/ErrorUtils.h"

CNSGAII::CNSGAII(AProblem &evaluator,
                 AInitialization &initialization,
                 CRankedTournament &rankedTournament,
                 ACrossover &crossover,
                 AMutation &mutation,
                 SConfigMap *configMap
) :
        AMOGeneticMethod(evaluator, initialization, crossover, mutation),
        m_RankedTournament(rankedTournament)
{
    configMap->TakeValue("PopulationSize", m_PopulationSize);
    ErrorUtils::LowerThanZeroI("NSGAII", "PopulationSize", m_PopulationSize);
    m_Population.reserve(m_PopulationSize);
    m_NextPopulation.reserve(m_PopulationSize);

    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    ErrorUtils::LowerThanZeroI("NSGAII", "GenerationLimit", m_GenerationLimit);
}


void CNSGAII::RunOptimization()
{
    int generation = 0;

    for (size_t i = 0; i < m_PopulationSize; ++i)
    {
        SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
        auto* newInd = m_Initialization.CreateMOIndividual(problemEncoding);

        m_Problem.Evaluate(*newInd);

        m_Population.push_back(newInd);
    }

    ArchiveUtils::CopyToArchiveWithFiltering(m_Population, m_Archive);

    while (generation < m_GenerationLimit)
    {
        EvolveToNextGeneration();

        std::vector<SMOIndividual *> combinedPop;
        combinedPop.reserve(m_Population.size() + m_NextPopulation.size());
        combinedPop.insert(combinedPop.end(), m_Population.begin(), m_Population.end());
        combinedPop.insert(combinedPop.end(), m_NextPopulation.begin(), m_NextPopulation.end());

        CNonDominatedSorting nonDominatedSorting;
        std::vector<std::vector<size_t>> combinedClusters;
        nonDominatedSorting.Cluster(combinedPop, combinedClusters);

        std::vector<SMOIndividual *> tempPopulation;
        tempPopulation.reserve(m_PopulationSize);
        for (size_t i = 0; tempPopulation.size() < m_PopulationSize; ++i)
        {
            std::vector<size_t> &cluster = combinedClusters[i];
            // if this cluster exceeds the size
            if (tempPopulation.size() + cluster.size() > m_PopulationSize)
            {
                CalcCrowdingDistance(combinedPop, cluster);
                std::sort(cluster.begin(), cluster.end(), [combinedPop](const size_t &a, const size_t &b) -> bool
                {
                    return combinedPop[a]->m_CrowdingDistance < combinedPop[b]->m_CrowdingDistance;
                });
                for (size_t idx: cluster)
                {
                    // deep copy individuals as they fill be the new population
                    tempPopulation.push_back(new SMOIndividual(*combinedPop[idx]));
                    if (tempPopulation.size() >= m_PopulationSize)
                        break;
                }
            }
            else
            {
                for (size_t idx: cluster)
                {
                    tempPopulation.push_back(new SMOIndividual(*combinedPop[idx]));
                }
            }
        }

        // Clear both current and next population
        for (SMOIndividual *ind: combinedPop)
        {
            delete ind;
        }
        m_Population.clear();
        m_NextPopulation.clear();

        m_Population.swap(tempPopulation);
        m_NextPopulation.reserve(m_Population.size());

        generation++;
    }

    ArchiveUtils::CopyToArchiveWithFiltering(m_NextPopulation, m_Archive);
    ArchiveUtils::LogParetoFront(m_Archive);
}

void CNSGAII::EvolveToNextGeneration()
{

    for (size_t i = 0; i < m_PopulationSize; i += 2)
    {
        auto *firstParent = m_RankedTournament.Select(m_Population);
        auto *secondParent = m_RankedTournament.Select(m_Population);

        auto *firstChild = new SMOIndividual{*firstParent};
        auto *secondChild = new SMOIndividual{*secondParent};

        m_Crossover.Crossover(
                m_Problem.GetProblemEncoding(),
                *firstParent,
                *secondParent,
                *firstChild,
                *secondChild
        );

        m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *firstChild);
        m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *secondChild);

        m_Problem.Evaluate(*firstChild);
        m_Problem.Evaluate(*secondChild);

        m_NextPopulation.emplace_back(firstChild);
        m_NextPopulation.emplace_back(secondChild);
    }
    ArchiveUtils::CopyToArchiveWithFiltering(m_NextPopulation, m_Archive);
}

void CNSGAII::CalcCrowdingDistance(std::vector<SMOIndividual *> &population, std::vector<size_t> &indices)
{
    for (int objIdx = 0; objIdx < m_Problem.GetProblemEncoding().m_objectivesNumber; ++objIdx)
    {
        std::sort(indices.begin(), indices.end(), [objIdx, population](const size_t &a, const size_t &b) -> bool
        {
            return population[a]->m_NormalizedEvaluation[objIdx] < population[b]->m_NormalizedEvaluation[objIdx];
        });

        population[indices[0]]->m_CrowdingDistance = FLT_MAX;
        population[indices[indices.size() - 1]]->m_CrowdingDistance = FLT_MAX;

        for (size_t i = 1; i < indices.size() - 1; ++i)
        {
            float currDist = population[indices[i]]->m_CrowdingDistance;
            float plusValue = population[indices[i + 1]]->m_NormalizedEvaluation[objIdx];
            float minusValue = population[indices[i - 1]]->m_NormalizedEvaluation[objIdx];
            population[indices[i]]->m_CrowdingDistance = currDist + plusValue - minusValue;
        }
    }
}

optimizer\src\method\methods\MO\NTGA2\CNTGA2.cpp
=============
#include <algorithm>
#include <sstream>
#include "CNTGA2.h"
#include "../utils/archive/ArchiveUtils.h"
#include "../utils/clustering/CNonDominatedSorting.h"
#include "../../../../utils/logger/ErrorUtils.h"

CNTGA2::CNTGA2(AProblem &evaluator,
               AInitialization &initialization,
               CRankedTournament &rankedTournament,
               CGapSelectionByRandomDim &gapSelection,
               ACrossover &crossover,
               AMutation &mutation,
               SConfigMap *configMap
) :
        AMOGeneticMethod(evaluator, initialization, crossover, mutation),
        m_RankedTournament(rankedTournament),
        m_GapSelection(gapSelection)
{
    configMap->TakeValue("GapSelectionPercent", m_GapSelectionPercent);
    ErrorUtils::OutOfScopeF("NTGA2", "GapSelectionPercent", m_GapSelectionPercent / 100.f);

    configMap->TakeValue("PopulationSize", m_PopulationSize);
    ErrorUtils::LowerThanZeroI("NTGA2", "PopulationSize", m_PopulationSize);
    m_Population.reserve(m_PopulationSize);
    m_NextPopulation.reserve(m_PopulationSize);

    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    ErrorUtils::LowerThanZeroI("NTGA2", "GenerationLimit", m_GenerationLimit);
}


void CNTGA2::RunOptimization()
{
    int generation = 0;

    for (size_t i = 0; i < m_PopulationSize; ++i)
    {
        SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
        auto* newInd = m_Initialization.CreateMOIndividual(problemEncoding);

        m_Problem.Evaluate(*newInd);

        m_Population.push_back(newInd);
    }

    ArchiveUtils::CopyToArchiveWithFiltering(m_Population, m_Archive);

    while (generation < m_GenerationLimit)
    {
        if ((generation % 100) < (100 - m_GapSelectionPercent))
        {
            // Without Gap
            std::vector<SMOIndividual *> parentsVector;
            parentsVector.reserve(m_Archive.size() + m_Population.size());
            parentsVector.insert(parentsVector.end(), m_Archive.begin(), m_Archive.end());
            parentsVector.insert(parentsVector.end(), m_Population.begin(), m_Population.end());

            CNonDominatedSorting nonDominatedSorting;
            std::vector<std::vector<size_t>> combinedClusters;
            nonDominatedSorting.Cluster(parentsVector, combinedClusters);

            for (size_t i = 0; i < m_PopulationSize; i += 2)
            {
                auto *firstParent = m_RankedTournament.Select(m_Population);
                auto *secondParent = m_RankedTournament.Select(m_Population);

                CrossoverAndMutate(*firstParent, *secondParent);
            }
        }
        else
        {
            // Evolve with Gap
            const auto &parents = m_GapSelection.Select(
                    m_Archive,
                    m_Problem.GetProblemEncoding().m_objectivesNumber,
                    m_PopulationSize
            );
            for (auto& parentPair : parents)
            {
                CrossoverAndMutate(*parentPair.first, *parentPair.second);
            }
        }
        ArchiveUtils::CopyToArchiveWithFiltering(m_NextPopulation, m_Archive);

        for (SMOIndividual *ind: m_Population)
        {
            delete ind;
        }
        m_Population = m_NextPopulation;
        m_NextPopulation.clear();
        m_NextPopulation.reserve(m_Population.size());

        ++generation;
    }

    ArchiveUtils::LogParetoFront(m_Archive);
}

void CNTGA2::CrossoverAndMutate(SMOIndividual &firstParent, SMOIndividual &secondParent)
{
    auto *firstChild = new SMOIndividual{firstParent};
    auto *secondChild = new SMOIndividual{secondParent};

    m_Crossover.Crossover(
            m_Problem.GetProblemEncoding(),
            firstParent,
            secondParent,
            *firstChild,
            *secondChild
    );

    m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *firstChild);
    m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *secondChild);

    m_Problem.Evaluate(*firstChild);
    m_Problem.Evaluate(*secondChild);

    m_NextPopulation.emplace_back(firstChild);
    m_NextPopulation.emplace_back(secondChild);
}

optimizer\src\method\methods\MO\NTGA2_ALNS\CNTGA2_ALNS.cpp
=============
#include <algorithm>
#include <sstream>
#include "CNTGA2_ALNS.h"
#include "../utils/archive/ArchiveUtils.h"
#include "../utils/clustering/CNonDominatedSorting.h"
#include "../../../../utils/logger/ErrorUtils.h"
#include "../../../../utils/random/CRandom.h"
#include "../../../../utils/logger/CExperimentLogger.h"

CNTGA2_ALNS::CNTGA2_ALNS(AProblem &evaluator,
    AInitialization &initialization,
    CRankedTournament &rankedTournament,
    CGapSelectionByRandomDim &gapSelection,
    ACrossover &crossover,
    AMutation &mutation,
    SConfigMap *configMap,
    std::vector<AMutation*>& alnsRemovalMutations,
    std::vector<AMutation*>& alnsInsertionMutations
) :
        AMOGeneticMethod(evaluator, initialization, crossover, mutation),
        m_RankedTournament(rankedTournament),
        m_GapSelection(gapSelection),
        m_alnsRemovalMutations(alnsRemovalMutations),
        m_alnsInsertionMutations(alnsInsertionMutations)
{
    configMap->TakeValue("GapSelectionPercent", m_GapSelectionPercent);
    ErrorUtils::OutOfScopeF("NTGA2_ALNS", "GapSelectionPercent", m_GapSelectionPercent / 100.f); // Assuming this checks for a valid percentage range

    configMap->TakeValue("PopulationSize", m_PopulationSize);
    ErrorUtils::LowerThanZeroI("NTGA2_ALNS", "PopulationSize", m_PopulationSize);
    m_Population.reserve(m_PopulationSize);
    m_NextPopulation.reserve(m_PopulationSize);
    m_PreviousPopulation.reserve(m_PopulationSize);

    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    ErrorUtils::LowerThanZeroI("NTGA2_ALNS", "GenerationLimit", m_GenerationLimit);

    configMap->TakeValue("EffectivnessThreshold", m_effectivnessThreshold);
    ErrorUtils::LowerThanZeroF("NTGA2_ALNS", "EffectivnessThreshold", m_effectivnessThreshold);

    configMap->TakeValue("ALNSIterations", m_ALNSIterations);
    ErrorUtils::LowerThanZeroI("NTGA2_ALNS", "ALNSIterations", m_ALNSIterations);

    configMap->TakeValue("ALNSNoImprovementIterations", m_ALNSNoImprovementIterations);
    ErrorUtils::LowerThanZeroI("NTGA2_ALNS", "ALNSNoImprovementIterations", m_ALNSNoImprovementIterations);

    configMap->TakeValue("ALNSProbabilityStepsIterations", m_ALNSProbabilityStepsIterations);
    ErrorUtils::LowerThanZeroI("NTGA2_ALNS", "ALNSProbabilityStepsIterations", m_ALNSProbabilityStepsIterations);

    configMap->TakeValue("ALNSStartTemperature", m_ALNSStartTemperature);
    ErrorUtils::LowerThanZeroI("NTGA2_ALNS", "ALNSStartTemperature", m_ALNSStartTemperature);

    configMap->TakeValue("ALNSTemperatureAnnealingRate", m_ALNSTemperatureAnnealingRate);
    ErrorUtils::LowerThanZeroI("NTGA2_ALNS", "ALNSTemperatureAnnealingRate", m_ALNSTemperatureAnnealingRate);

    configMap->TakeValue("ALNSProbabilityPercent", m_ALNSProbabilityPercent);
    ErrorUtils::OutOfScopeF("NTGA2_ALNS", "ALNSProbabilityPercent", m_ALNSProbabilityPercent / 100.f);
}

void CNTGA2_ALNS::RunOptimization()
{
    int generation = 0;

    for (size_t i = 0; i < m_PopulationSize; ++i)
    {
        SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
        auto* newInd = m_Initialization.CreateMOIndividual(problemEncoding);

        m_Problem.Evaluate(*newInd);

        m_Population.push_back(newInd);
    }

    ArchiveUtils::CopyToArchiveWithFiltering(m_Population, m_Archive);

    while (generation < m_GenerationLimit)
    {
        CExperimentLogger::LogProgress(generation / (float)m_GenerationLimit);
        if ((generation % 100) < (100 - m_GapSelectionPercent))
        {
            RunGeneration();
        }
        else
        {
            RunGenerationWithGap();
        }

        ArchiveUtils::CopyToArchiveWithFiltering(m_NextPopulation, m_Archive);

        for (SMOIndividual *ind: m_PreviousPopulation)
        {
            delete ind;
        }
        m_PreviousPopulation = m_Population;
        m_Population = m_NextPopulation;
        m_NextPopulation.clear();
        m_NextPopulation.reserve(m_Population.size());

        ++generation;
    }

    LogResult();
}

void CNTGA2_ALNS::RunGeneration()
{
    std::vector<SMOIndividual*> parentsVector;
    parentsVector.reserve(m_Archive.size() + m_Population.size());
    parentsVector.insert(parentsVector.end(), m_Archive.begin(), m_Archive.end());
    parentsVector.insert(parentsVector.end(), m_Population.begin(), m_Population.end());

    CNonDominatedSorting nonDominatedSorting;
    std::vector<std::vector<size_t>> combinedClusters;
    nonDominatedSorting.Cluster(parentsVector, combinedClusters);

    bool shouldUseALNS = ShouldUseALNS(m_PreviousPopulation, m_Population);

    for (size_t i = 0; i < m_PopulationSize; i += 2)
    {
        auto* firstParent = m_RankedTournament.Select(m_Population);
        auto* secondParent = m_RankedTournament.Select(m_Population);

        if (shouldUseALNS && CRandom::GetInt(0, 101) < m_ALNSProbabilityPercent) {
            auto* firstChild = RunALNS(*firstParent);
            auto* secondChild = RunALNS(*secondParent);
            EvaluateAndAdd(*firstChild);
            EvaluateAndAdd(*secondChild);
        }
        else {
            CrossoverAndMutate(*firstParent, *secondParent);
        }
    }
}

void CNTGA2_ALNS::RunGenerationWithGap()
{
    const auto& parents = m_GapSelection.Select(
        m_Archive,
        m_Problem.GetProblemEncoding().m_objectivesNumber,
        m_PopulationSize
    );
    bool shouldUseALNS = ShouldUseALNS(m_PreviousPopulation, m_Population);

    for (auto parentsPair : parents) {
        if (shouldUseALNS && CRandom::GetInt(0, 101) < m_ALNSProbabilityPercent) {
            auto* firstChild = RunALNS(*parentsPair.first);
            auto* secondChild = RunALNS(*parentsPair.second);
            EvaluateAndAdd(*firstChild);
            EvaluateAndAdd(*secondChild);
        }
        else {
            CrossoverAndMutate(*parentsPair.first, *parentsPair.second);
        }
    }
}

void CNTGA2_ALNS::CrossoverAndMutate(SMOIndividual &firstParent, SMOIndividual &secondParent)
{
    auto *firstChild = new SMOIndividual{firstParent};
    auto *secondChild = new SMOIndividual{secondParent};

    m_Crossover.Crossover(
            m_Problem.GetProblemEncoding(),
            firstParent,
            secondParent,
            *firstChild,
            *secondChild
    );

    m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *firstChild);
    m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *secondChild);

    EvaluateAndAdd(*firstChild);
    EvaluateAndAdd(*secondChild);
}

void CNTGA2_ALNS::EvaluateAndAdd(SMOIndividual& individual)
{
    m_Problem.Evaluate(individual);
    m_NextPopulation.emplace_back(&individual);
}

bool CNTGA2_ALNS::ShouldUseALNS(std::vector<SMOIndividual*>& previousPopulation, std::vector<SMOIndividual*> currentPopulation) 
{
    float previousAverageEvaluation = 0;
    float currentAverageEvaluation = 0;
    float evaluationPoints = 0;
    for (int i = 0; i < previousPopulation.size(); i++) {
        for (int j = 0; j < previousPopulation[i]->m_Evaluation.size(); j++) {
            evaluationPoints += previousPopulation[i]->m_Evaluation[j];
        }
    }
    previousAverageEvaluation += evaluationPoints / m_PreviousPopulation.size();
    evaluationPoints = 0;
    for (int i = 0; i < currentPopulation.size(); i++) {
        for (int j = 0; j < currentPopulation[i]->m_Evaluation.size(); j++) {
            evaluationPoints += currentPopulation[i]->m_Evaluation[j];
        }
    }
    currentAverageEvaluation += evaluationPoints / m_PreviousPopulation.size();
    if ((currentAverageEvaluation / previousAverageEvaluation) - 1 < m_effectivnessThreshold) {
        return true;
    }
    return false;
}

bool CNTGA2_ALNS::AcceptWorseSolution(SMOIndividual& generated, SMOIndividual& current, float temperature)
{
    return CRandom::GetFloat(0, 1) < exp((generated.m_Evaluation[0] - current.m_Evaluation[0]) / temperature);
}

SMOIndividual* CNTGA2_ALNS::RunALNS(SMOIndividual& parent) 
{
    auto* best = new SMOIndividual{ parent };
    auto* current = new SMOIndividual{ *best };
    int iteration = 1;
    int iterationsWithoutImprovement = 0;
    float temperature = 0;
    std::vector<float> removalOperatorsProbabilityDistribution(m_alnsRemovalMutations.size(), 1.0f/m_alnsRemovalMutations.size());
    std::vector<float> insertionOperatorsProbabilityDistribution(m_alnsInsertionMutations.size(), 1.0f / m_alnsInsertionMutations.size());
    std::map<AMutation*, std::tuple<float, int>> removalOperatorsScores;
    std::map<AMutation*, std::tuple<float, int>> insertOperatorsScores;
    m_Problem.Evaluate(*current);
    while (iteration < (m_ALNSIterations + 1) && iterationsWithoutImprovement < m_ALNSNoImprovementIterations) 
    {
        auto* generated = new SMOIndividual(*current);
        auto& removalOperator = m_alnsRemovalMutations[CRandom::GetWeightedInt(removalOperatorsProbabilityDistribution)];
        auto& insertOperator = m_alnsInsertionMutations[CRandom::GetWeightedInt(insertionOperatorsProbabilityDistribution)];
        removalOperator->Mutate(m_Problem.GetProblemEncoding(), *generated);
        insertOperator->Mutate(m_Problem.GetProblemEncoding(), *generated);
        m_Problem.Evaluate(*generated);
        if (generated->m_isValid) 
        {
            if (generated->m_Evaluation[0] + generated->m_Evaluation[1] < current->m_Evaluation[0] + current->m_Evaluation[1])
            {
                delete current;
                current = generated;
                iterationsWithoutImprovement = 0;
                if (current->m_Evaluation[0] + current->m_Evaluation[1] < best->m_Evaluation[0] + best->m_Evaluation[1])
                {
                    delete best;
                    best = new SMOIndividual{ *current };
                }
            }
            else if(AcceptWorseSolution(*generated, *current, temperature)) 
            {
                delete current;
                current = generated;
                iterationsWithoutImprovement++;
            }
        }
        else if(AcceptWorseSolution(*generated, *current, temperature)) 
        {
            delete current;
            current = generated;
            iterationsWithoutImprovement++;
        }
        else 
        {
            iterationsWithoutImprovement++;
        }

        UpdateScores(current, 
            best, 
            removalOperator, 
            insertOperator, 
            removalOperatorsScores, 
            insertOperatorsScores
        );

        if (iteration % m_ALNSProbabilityStepsIterations == 0)
        {
            UpdateProbabilityTables(removalOperatorsScores,
                removalOperatorsProbabilityDistribution,
                insertOperatorsScores,
                insertionOperatorsProbabilityDistribution
            );
        }

        iteration++;      

        temperature = temperature * m_ALNSTemperatureAnnealingRate;
    }
    return best;
}

void CNTGA2_ALNS::UpdateScores(SMOIndividual* current, 
    SMOIndividual* best, 
    AMutation*& removalOperator,
    AMutation*& insertOperator,
    std::map<AMutation*, std::tuple<float, int>>& removalOperatorsScores,
    std::map<AMutation*, std::tuple<float, int>>& insertOperatorsScores
) 
{
    float scoreIncrease = (current->m_Evaluation[0] + current->m_Evaluation[1]) - (best->m_Evaluation[0] + best->m_Evaluation[1]);
    if (removalOperatorsScores.count(removalOperator))
    {
        removalOperatorsScores[removalOperator] = std::tuple<float, int>(std::get<0>(removalOperatorsScores[removalOperator]) + scoreIncrease, ++std::get<1>(removalOperatorsScores[removalOperator]));
    }
    else
    {
        removalOperatorsScores.emplace(removalOperator, std::tuple<float, int>(scoreIncrease, 1));
    }
    if (insertOperatorsScores.count(insertOperator))
    {
        insertOperatorsScores[insertOperator] = std::tuple<float, int>(std::get<0>(insertOperatorsScores[insertOperator]) + scoreIncrease, ++std::get<1>(insertOperatorsScores[insertOperator]));
    }
    else
    {
        insertOperatorsScores.emplace(insertOperator, std::tuple<float, int>(scoreIncrease, 1));
    }
}

void CNTGA2_ALNS::UpdateProbabilityTables(std::map<AMutation*, std::tuple<float, int>>& removalOperatorsScores, 
    std::vector<float>& removalOperatorsProbabilityDistribution,
    std::map<AMutation*, std::tuple<float, int>>& insertOperatorsScores,
    std::vector<float>& insertionOperatorsProbabilityDistribution
)
{
    float probabilityChange = CRandom::GetFloat(0.01f, 0.05f);
    if (removalOperatorsScores.size() >= 2) {
        using pair_type = std::map<AMutation*, std::tuple<float, int>>::value_type;
        auto best = std::min_element(removalOperatorsScores.begin(), removalOperatorsScores.end(), [](const pair_type& p1, const pair_type& p2)
            {
                return std::get<0>(p1.second) / std::get<1>(p1.second) < std::get<0>(p2.second) / std::get<1>(p2.second);
            });
        auto worst = std::max_element(removalOperatorsScores.begin(), removalOperatorsScores.end(), [](const pair_type& p1, const pair_type& p2)
            {
                return std::get<0>(p1.second) / std::get<1>(p1.second) < std::get<0>(p2.second) / std::get<1>(p2.second);
            });
        removalOperatorsProbabilityDistribution[std::find(m_alnsRemovalMutations.begin(), m_alnsRemovalMutations.end(), best->first) - m_alnsRemovalMutations.begin()] += probabilityChange;
        removalOperatorsProbabilityDistribution[std::find(m_alnsRemovalMutations.begin(), m_alnsRemovalMutations.end(), worst->first) - m_alnsRemovalMutations.begin()] -= probabilityChange;
    }
    if (insertOperatorsScores.size() >= 2) {
        using pair_type = std::map<AMutation*, std::tuple<float, int>>::value_type;
        auto best = std::min_element(insertOperatorsScores.begin(), insertOperatorsScores.end(), [](const pair_type& p1, const pair_type& p2)
            {
                return std::get<0>(p1.second) / std::get<1>(p1.second) < std::get<0>(p2.second) / std::get<1>(p2.second);
            });
        auto worst = std::max_element(insertOperatorsScores.begin(), insertOperatorsScores.end(), [](const pair_type& p1, const pair_type& p2)
            {
                return std::get<0>(p1.second) / std::get<1>(p1.second) < std::get<0>(p2.second) / std::get<1>(p2.second);
            });
        insertionOperatorsProbabilityDistribution[std::find(m_alnsInsertionMutations.begin(), m_alnsInsertionMutations.end(), best->first) - m_alnsInsertionMutations.begin()] += probabilityChange;
        insertionOperatorsProbabilityDistribution[std::find(m_alnsInsertionMutations.begin(), m_alnsInsertionMutations.end(), worst->first) - m_alnsInsertionMutations.begin()] -= probabilityChange;
    }
}

void CNTGA2_ALNS::LogResult()
{
    ArchiveUtils::LogParetoFront(m_Archive);
    for (int i = 0; i < m_Archive.size(); i++) {
        m_Problem.LogSolution(*m_Archive[i]);
    }
    CExperimentLogger::LogData();
    m_Problem.LogAdditionalData();
}

optimizer\src\method\methods\MO\SPEA2\CSPEA2.cpp
=============
#include <algorithm>
#include <sstream>
#include "CSPEA2.h"
#include "../utils/archive/ArchiveUtils.h"
#include "../utils/DasDennis/CDasDennis.h"
#include "../../../../utils/random/CRandom.h"
#include "../../../../utils/logger/ErrorUtils.h"

CSPEA2::CSPEA2(AProblem &problem, AInitialization &initialization, ACrossover &crossover, AMutation &mutation, SConfigMap *configMap)
        : AMOGeneticMethod(problem, initialization, crossover, mutation)
{
    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    ErrorUtils::LowerThanZeroI("CSPEA2", "GenerationLimit", m_GenerationLimit);

    configMap->TakeValue("PopulationSize", m_PopulationSize);
    ErrorUtils::LowerThanZeroI("CSPEA2", "PopulationSize", m_PopulationSize);
    m_Population.reserve(m_PopulationSize);

    configMap->TakeValue("ArchiveSize", m_ArchiveSize);
    ErrorUtils::LowerThanZeroI("CSPEA2", "ArchiveSize", m_ArchiveSize);
    m_Archive.reserve(m_ArchiveSize);
}


void CSPEA2::RunOptimization()
{
    int generation = 0;

    for (size_t i = 0; i < m_PopulationSize; ++i)
    {
        SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
        auto* newInd = m_Initialization.CreateMOIndividual(problemEncoding);

        m_Problem.Evaluate(*newInd);

        m_Population.push_back(newInd);
    }

    std::vector<TNeighborhood> neighborhood;
    BuildNeighborhood(m_Population, neighborhood);
    UpdateFineGrainedFitness(m_Population, neighborhood);
    
    ArchiveUtils::CopyToArchiveWithFiltering(m_Population, m_Archive);

    while ( generation < m_GenerationLimit)
    {
        EvolveToNextGeneration();

        std::vector<SMOIndividual*> combinedPop;
        combinedPop.reserve(m_Population.size() + m_Archive.size());
        combinedPop.insert(combinedPop.end(), m_Population.begin(), m_Population.end());
        combinedPop.insert(combinedPop.end(), m_Archive.begin(), m_Archive.end());

        BuildNeighborhood(combinedPop, neighborhood);
        UpdateFineGrainedFitness(combinedPop, neighborhood);
        EnviroSelection(combinedPop);
        
        generation++;
    }

    std::vector<SMOIndividual*> allArchiveInd = m_Archive;
    m_Archive.clear();
    ArchiveUtils::CopyToArchiveWithFiltering(allArchiveInd, m_Archive);
    for (SMOIndividual* ind : allArchiveInd)
    {
        delete ind;
    }
    
    ArchiveUtils::CopyToArchiveWithFiltering(m_NextPopulation, m_Archive);
    ArchiveUtils::LogParetoFront(m_Archive);
}

void CSPEA2::EvolveToNextGeneration()
{
    for (size_t i = 0; i < m_Population.size(); i += 2)
    {
        size_t firstParentIdx = Spea2TournamentSelection(m_Archive);
        size_t secondParentIdx = Spea2TournamentSelection(m_Archive);
        SMOIndividual* firstParent = m_Archive[firstParentIdx];
        SMOIndividual* secondParent = m_Archive[secondParentIdx];

        auto *firstChild = new SMOIndividual{*firstParent};
        auto *secondChild = new SMOIndividual{*secondParent};

        m_Crossover.Crossover(
                m_Problem.GetProblemEncoding(),
                *firstParent,
                *secondParent,
                *firstChild,
                *secondChild
        );

        m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *firstChild);
        m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *secondChild);

        m_Problem.Evaluate(*firstChild);
        m_Problem.Evaluate(*secondChild);

        delete m_Population[i];
        delete m_Population[i + 1];
        m_Population[i] = firstChild;
        m_Population[i + 1] = secondChild;
    }
}

void CSPEA2::BuildNeighborhood(std::vector<SMOIndividual *>& individuals, std::vector<TNeighborhood>& neighborhood)
{
    neighborhood = std::vector<TNeighborhood>(individuals.size(), TNeighborhood(individuals.size() - 1));
    size_t popSize = individuals.size();

    for (size_t i = 0; i < popSize; ++i)
    {
        size_t entryIdx = 0;
        for (size_t j = 0; j < popSize; ++j)
        {
            // just skip if self
            if (i == j)
            {
                continue;
            }

            std::pair<size_t, float>& entry = neighborhood[i][entryIdx];
            entry.first = j;
            entry.second = CalcDist(*individuals[i], *individuals[j]);
            ++entryIdx;
        }
    }

    // Sort ascending by distance
    for (TNeighborhood& nh : neighborhood)
    {
        std::sort(nh.begin(), nh.end(), [](const std::pair<size_t, float>& a, const std::pair<size_t, float>& b) -> bool
        {
            return a.second < b.second;
        });
    }
}

float CSPEA2::CalcDist(const SMOIndividual& leftInd, const SMOIndividual& rightInd)
{
    size_t objCount = m_Problem.GetProblemEncoding().m_objectivesNumber;
    float dist = 0.f;
    for (int i = 0; i < objCount; ++i)
    {
        // non norm
        dist += powf(rightInd.m_NormalizedEvaluation[i] - leftInd.m_NormalizedEvaluation[i], 2);
    }
    return sqrtf(dist);
}

void CSPEA2::UpdateFineGrainedFitness(std::vector<SMOIndividual*>& individuals, const std::vector<TNeighborhood>& neighborhood)
{
    UpdateRawFitness(individuals);
    UpdateDensity(individuals, neighborhood);
}

void CSPEA2::UpdateRawFitness(std::vector<SMOIndividual*>& individuals)
{
    size_t indSize = individuals.size();
    std::vector<size_t> strengthVector(indSize, 0);
    std::vector<std::vector<size_t>> dominators(indSize, std::vector<size_t>());

    // R(i) -> rank
    for (size_t i = 0; i < indSize; ++i)
    {
        for (size_t j = 0; j < indSize; ++j)
        {
            if (i == j)
                continue;

            if (individuals[i]->IsDominatedBy(individuals[j]))
            {
                // Mark that Ind J dominates Ind I
                dominators[i].push_back(j);
                // Increase Ind J strength
                strengthVector[j] += 1;
            }
        }
    }

    for (size_t i = 0; i < indSize; ++i)
    {
        size_t totalDominatorsStrength = 0;
        for (size_t domIdx : dominators[i])
        {
            totalDominatorsStrength += strengthVector[domIdx];
        }
        individuals[i]->m_Rank = totalDominatorsStrength;
    }
}

void CSPEA2::UpdateDensity(std::vector<SMOIndividual*>& individuals, const std::vector<TNeighborhood>& neighborhood)
{
    // D(i) -> CrowdDist
    size_t k = sqrtf(m_PopulationSize + m_ArchiveSize);

    for (size_t i = 0; i < individuals.size(); ++i)
    {
        individuals[i]->m_CrowdingDistance = neighborhood[i][k].second;
    }
}

void CSPEA2::EnviroSelection(std::vector<SMOIndividual*>& individuals)
{
    auto* archiveCopy = new std::vector<SMOIndividual*>();
    archiveCopy->reserve(m_Archive.size());  // Reserve space
    std::copy(m_Archive.begin(), m_Archive.end(), std::back_inserter(*archiveCopy));  // Copy pointers

    m_Archive.clear();
    
    std::vector<const SMOIndividual*> nonDominatedIndividuals;
    std::vector<const SMOIndividual*> dominatedIndividuals;
    SplitByDomination(individuals, dominatedIndividuals, nonDominatedIndividuals);

    int sizeDiff = (int)m_ArchiveSize - (int)nonDominatedIndividuals.size();
    if (sizeDiff > 0)
    {
        // Add dominated individuals with good results
        std::sort(dominatedIndividuals.begin(), dominatedIndividuals.end(), [](const SMOIndividual* a, const SMOIndividual* b) -> bool
        {
            return (a->m_Rank + a->m_CrowdingDistance) < (b->m_Rank + b->m_CrowdingDistance);
        });
        for (int i = 0; i < sizeDiff; ++i)
        {
            nonDominatedIndividuals.push_back(dominatedIndividuals[i]);
        }
    }
    else if (nonDominatedIndividuals.size() > m_ArchiveSize)
    {
        // Remove most crowded individuals
        TruncateByDistance(nonDominatedIndividuals, m_ArchiveSize);
    }
    
    // Finally, add new individuals to the archive
    for (const SMOIndividual* filteredInd : nonDominatedIndividuals)
    {
        m_Archive.push_back(new SMOIndividual(*filteredInd));
    }
    
    // Ensure that old archive is deleted
    for (auto* oldIndividual: *archiveCopy) {
        delete oldIndividual;
    }
    delete archiveCopy;
}

void CSPEA2::SplitByDomination(std::vector<SMOIndividual*>& individuals, std::vector<const SMOIndividual*>& dominatedIndividuals, std::vector<const SMOIndividual*>& nonDominatedIndividuals)
{
    nonDominatedIndividuals.clear();
    nonDominatedIndividuals.reserve(individuals.size());
    dominatedIndividuals.clear();
    dominatedIndividuals.reserve(individuals.size());
    // For each new individual, check if not dominated
    // We don't have to check if the same solution, equal rewards are discarded
    for (size_t p = 0; p < individuals.size(); ++p)
    {
        const SMOIndividual* newInd = individuals[p];
        bool isDominated = false;
        // Check other new individuals
        size_t i = 0;
        while (!isDominated && i < individuals.size())
        {
            if (p != i)
            {
                isDominated = newInd->IsDominatedBy(individuals[i]);
                if (!isDominated && p < i) // If DuplicateFenotype - leave the last one
                {
                    // Check if duplicated
                    isDominated = newInd->IsDuplicateEvalValue(individuals[i]);
                }
            }
            ++i;
        }
        if (isDominated)
        {
            dominatedIndividuals.push_back(newInd);
        }
        else
        {
            nonDominatedIndividuals.push_back(newInd);
        }
    }
}

void CSPEA2::TruncateByDistance(std::vector<const SMOIndividual*>& filteredIndividuals, size_t maxSize)
{
    // also simplified - remove first closest point
    while (filteredIndividuals.size() > maxSize)
    {
        float maxDist = 0.f;
        size_t toRemove = 0;
        for (size_t i = 0; i < filteredIndividuals.size(); ++i)
        {
            for (size_t j = i + 1; j < filteredIndividuals.size(); ++j)
            {
                float d = CalcDist(*filteredIndividuals[i], *filteredIndividuals[j]);
                if (d > maxDist)
                {
                    maxDist = d;
                    toRemove = i;
                }
            }
        }

        filteredIndividuals.erase(filteredIndividuals.begin() + toRemove);
    }
}

size_t CSPEA2::Spea2TournamentSelection(const std::vector<SMOIndividual*>& population)
{
    // binary selection
    size_t tournamentSize = 2;
    size_t popSize = population.size();

    size_t bestIdx = CRandom::GetInt(0, popSize);
    // fitness to be minimized
    float bestFitness = (float)population[bestIdx]->m_Rank + population[bestIdx]->m_CrowdingDistance;

    for (size_t i = 1; i < tournamentSize; ++i)
    {
        size_t randomIdx = CRandom::GetInt(0, popSize);
        float fitness = (float)population[randomIdx]->m_Rank + population[randomIdx]->m_CrowdingDistance;
        if (fitness < bestFitness)
        {
            bestFitness = fitness;
            bestIdx = randomIdx;
        }
    }

    return bestIdx;
}

optimizer\src\method\methods\MO\utils\archive\ArchiveUtils.cpp
=============
﻿#include "ArchiveUtils.h"
#include "utils/logger/CExperimentLogger.h"
#include "utils/dataStructures/CCSV.h"

#include <ostream>
#include <fstream>
#include <algorithm>
#include <sstream>

#define USE_EVAL_DUPLICATE 1

void ArchiveUtils::CopyToArchiveWithFiltering(const std::vector<SMOIndividual*>& individuals,
                                              std::vector<SMOIndividual*>& archive)
{
    std::vector<const SMOIndividual*> filteredIndividuals;
    filteredIndividuals.reserve(individuals.size());

    // For each new individual, check if not dominated or not dominating
    // We don't have to check if the same solution, equal rewards are discarded
    for (size_t p = 0; p < individuals.size(); ++p)
    {
        const SMOIndividual* newInd = individuals[p];
        bool isDominated = false;
        // Check other new individuals
        size_t i = 0;
        while (!isDominated && i < individuals.size())
        {
            if (p != i)
            {
                isDominated = newInd->IsDominatedBy(individuals[i]);
                if (!isDominated && p < i) // If DuplicateFenotype - leave the last one
                {
                    // Check if duplicated
#if USE_EVAL_DUPLICATE
                    isDominated = newInd->IsDuplicateEvalValue(individuals[i]);
#else
                    isDominated = newInd->IsDuplicateGenotype(individuals[i]);
#endif
                }
            }
            ++i;
        }
        // Check individuals in archive
        i = 0;
        while (!isDominated && i < archive.size())
        {
            //if (p != i)
            {
                isDominated = newInd->IsDominatedBy(archive[i]);
                if (!isDominated)
                {
                    // Chick if duplicated
#if USE_EVAL_DUPLICATE
                    isDominated = newInd->IsDuplicateEvalValue(archive[i]);
#else
                    isDominated = newInd->IsDuplicateGenotype(archive[i]);
#endif
                }
            }

            ++i;
        }
        if (!isDominated)
        {
            filteredIndividuals.push_back(newInd);
        }
    }

    // Now check if already archived individuals are not dominated by new, remove otherwise
    archive.erase(std::remove_if(archive.begin(), archive.end(), [filteredIndividuals](const SMOIndividual* ind)
    {
        for (const SMOIndividual* filteredInd: filteredIndividuals)
        {
            if (ind->IsDominatedBy(filteredInd))
            {
                return true;
            }
        }
        return false;
    }), archive.end());

    // Finally, add new non-dominated individuals to the archive
    archive.reserve(archive.size() + filteredIndividuals.size());
    for (const SMOIndividual* filteredInd: filteredIndividuals)
    {
        // Make deep copy
        archive.push_back(new SMOIndividual(*filteredInd));
    }
}

void ArchiveUtils::CopyToArchiveWithFiltering(const SMOIndividual* individual, std::vector<SMOIndividual*>& archive)
{
    // Check if not dominated
    bool isDominated = false;
    size_t i = 0;
    // Check individuals in archive
    while (!isDominated && i < archive.size())
    {
        isDominated = individual->IsDominatedBy(archive[i]);
        if (!isDominated)
        {
            // Chick if duplicated
#if USE_EVAL_DUPLICATE
            isDominated = individual->IsDuplicateEvalValue(archive[i]);
#else
            isDominated = individual->IsDuplicateGenotype(m_Archive[i]);
#endif
        }
        ++i;
    }

    if (!isDominated)
    {
        // Now check if already archived individuals are not dominated by new, remove otherwise
        archive.erase(std::remove_if(archive.begin(), archive.end(), [individual](const SMOIndividual* ind)
        {
            return ind->IsDominatedBy(individual);
        }), archive.end());

        archive.push_back(new SMOIndividual(*individual));
    }
}

std::vector<std::vector<float>> ArchiveUtils::ToEvaluation(const std::vector<SMOIndividual*>& archive)
{
    std::vector<std::vector<float>> evalValues;
    evalValues.reserve(evalValues.size() + archive.size());
    for (const SMOIndividual* ind: archive)
    {
        evalValues.emplace_back(ind->m_Evaluation);
    }
    return evalValues;
}

void ArchiveUtils::LogParetoFront(const std::vector<SMOIndividual*>& archive)
{
    std::ostringstream oss;
    CCSV<float>::ToCSV(oss, ArchiveUtils::ToEvaluation(archive));
    CExperimentLogger::LogResult(oss.str().c_str());
}

optimizer\src\method\methods\MO\utils\clustering\CNonDominatedSorting.cpp
=============
#include "CNonDominatedSorting.h"

void CNonDominatedSorting::Cluster(std::vector<SMOIndividual *> &population, std::vector<std::vector<size_t>> &clusters)
{
    size_t popSize = population.size();
    std::vector<SSolution> solutions;
    solutions.reserve(popSize);
    for (size_t i = 0; i < popSize; ++i)
    {
        solutions.emplace_back(i);
    }

    // clusters == fronts
    clusters.push_back(std::vector<size_t>());

    for (size_t p = 0; p < popSize; ++p)
    {
        for (size_t q = 0; q < popSize; ++q)
        {
            if (p != q)
            {
                if (population[q]->IsDominatedBy(population[p]))
                {
                    solutions[p].m_DominatedSolutions.push_back(&(solutions[q]));
                }
                else if (population[p]->IsDominatedBy(population[q]))
                {
                    solutions[p].m_DominationCounter += 1;
                }
            }
        }
        if (solutions[p].m_DominationCounter == 0)
        {
            clusters[0].push_back(p);
        }
    }

    size_t rank = 1;
    while (!clusters[rank - 1].empty())
    {
        clusters.push_back(std::vector<size_t>());
        for (size_t solutionIdx: clusters[rank - 1])
        {
            for (SSolution *dominatedSolution: solutions[solutionIdx].m_DominatedSolutions)
            {
                dominatedSolution->m_DominationCounter -= 1;
                if (dominatedSolution->m_DominationCounter == 0)
                {
                    clusters[rank].push_back(dominatedSolution->m_Idx);
                }
            }
        }
        ++rank;
    }

    // Remove last, which is empty
    clusters.pop_back();

    // Assign ranks to population
    for (size_t c = 0; c < clusters.size(); ++c)
    {
        for (size_t i = 0; i < clusters[c].size(); ++i)
        {
            population[clusters[c][i]]->m_Rank = c;
        }
    }
}

CNonDominatedSorting::SSolution::SSolution(size_t i)
        : m_Idx(i), m_DominationCounter(0)
{
}


optimizer\src\method\methods\MO\utils\DasDennis\CDasDennis.cpp
=============
#include "CDasDennis.h"

DasDennis::DasDennis(size_t axisPartitions, size_t dimNumb)
: m_AxisPartitions(axisPartitions)
, m_DimensionNumber(dimNumb)
, m_M(dimNumb - 1)
{
}

size_t DasDennis::GetPointsNumber() const
{
	return BinomialCoefficient(m_AxisPartitions + m_DimensionNumber - 1, m_DimensionNumber - 1);
}

void DasDennis::GeneratePoints()
{
	m_Points.clear();

	std::vector<float> layer;
	for (size_t i = 0; i < m_AxisPartitions + 1; ++i)
	{
		layer.push_back(float(i) / float(m_AxisPartitions));
	}
	for (size_t i = 0; i < layer.size(); ++i)
	{
		std::vector<float> l1;
		l1.push_back(layer[i]);
		GenerateLayerRecursive(l1, 0, layer.size() - i);
	}
	for (size_t i = 0; i < m_Points.size(); ++i)
	{
		float s = SumVector(m_Points[i]);
		m_Points[i].push_back(1.f - s);
	}
}

void DasDennis::GenerateLayerRecursive(const std::vector<float>& layer, size_t d, size_t l)
{
	if (d == (m_M - 1))
	{
		m_Points.push_back(layer);
	}
	else
	{
		for (size_t i = 0; i < l; ++i)
		{
			std::vector<float> layerCopy = layer;
			layerCopy.push_back(float(i) / float(m_AxisPartitions));
			GenerateLayerRecursive(layerCopy, d + 1, l - i);
		}
	}
}

float DasDennis::SumVector(const std::vector<float> vec) const
{
	float s = 0;
	for (const float& f : vec)
	{
		s += f;
	}
	return s;
}

std::vector<float> DasDennis::Linspace(float start, float end, size_t partitions) const
{
	float stepSize = (end - start) / (partitions - 1);
	std::vector<float> points(partitions, 0.f);
	for (size_t i = 0; i < partitions; ++i)
	{
		points[i] = start + stepSize * i;
	}
	return points;
}

float DasDennis::BinomialCoefficient(size_t n, size_t k) const
{
	return Factorial(n) / float(Factorial(k) * Factorial(n - k));
}

size_t DasDennis::Factorial(size_t n) const
{
	return n <= 1 ? 1 : n * Factorial(n - 1);
}


optimizer\src\method\methods\SO\ACO\TSP-BASED\CACO_TSP.cpp
=============
#include "../../../../../utils/fileReader/CReadUtils.h"
#include "../../CAggregatedFitness.h"
#include "../../../../../utils/logger/CExperimentLogger.h"
#include "../../../../../utils/random/CRandom.h"
#include <algorithm>
#include <fstream>
#include <filesystem>
#include <iostream>
#include "CACO_TSP.h"

CACO_TSP::CACO_TSP(
        AProblem &evaluator,
        AInitialization &initialization,
        SConfigMap *configMap,
        std::vector<float> &objectiveWeights
) : CACO(evaluator, initialization,objectiveWeights) {
    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    configMap->TakeValue("ReducingMultiplier", m_ReducingMultiplier);
    configMap->TakeValue("PopulationSize", m_PopulationSize);
    std::string  initType ;
    configMap->TakeValue("InitType", initType);
    if(initType=="Uniform"){
        m_InitType=Uniform;
    }
    if(initType=="Distance"){
        m_InitType=Distance;
    }

    m_Population.reserve(m_PopulationSize);

    size_t numberOfCities = m_Problem.GetProblemEncoding().m_Encoding[0].m_SectionDescription.size();
    m_PheromoneMap = std::vector<std::vector<float>>(numberOfCities, std::vector<float>(numberOfCities, 0.0));

    m_DistanceMatrix = m_Problem.GetProblemEncoding().m_additionalProblemData;

}

void CACO_TSP::SavePheromoneMap(int generation) {
    std::filesystem::path baseDirPath("../sptest/map/");
    if (!std::filesystem::exists(baseDirPath)) {
        std::filesystem::create_directories(baseDirPath);
    }
    std::ofstream outFile("../sptest/map/"+std::to_string(generation) + ".txt");
    if (!outFile.is_open()) {
        std::cerr << "Error opening file: " << generation << std::endl;
        return;
    }

    for (const auto& row : m_PheromoneMap) {
        for (const float& value : row) {
            outFile << value << ' ';
        }
        outFile << '\n';
    }

    outFile.close();
}

void CACO_TSP::RunOptimization() {
    int generation = 0;
    ResetPheromoneMap();
    m_GloballyBest=GetRandomAnt();

    RandomAnts();
    LeavePheromone();
    AddExperimentData(generation);

    while (generation < m_GenerationLimit){
        RunAnts();
        GetBestRoute();
        AddExperimentData(generation);
        generation++;
        LeavePheromone();
    }

    m_Population.push_back(m_GloballyBest);
    m_GloballyBest= nullptr;
    AddExperimentData(generation);

    CExperimentLogger::LogData();
    LogResultData();
}

void CACO_TSP::GetBestRoute() {
    SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
    SGenotype newGenotype;

    auto numberOfCities = problemEncoding.m_Encoding[0].m_SectionDescription.size();
    auto start = 0;
    newGenotype.m_IntGenotype.push_back(start);
    auto currentPosition = start;
    std::vector<int> visited;
    visited.push_back(currentPosition);

    for (int i = 1; i < numberOfCities; i++) {
        float maxEvaluation = std::numeric_limits<float>::min();
        int nextPosition;
        for (int ii = 0; ii < numberOfCities; ii++) {
            auto found_element = std::find(visited.begin(), visited.end(), ii);
            if (found_element != visited.end()) {
                continue;
            }
            if (ii == currentPosition) {
                continue;
            }
            if (m_PheromoneMap[currentPosition][ii] > maxEvaluation) {
                maxEvaluation = m_PheromoneMap[currentPosition][ii];
                nextPosition = ii;
            }
        }

        newGenotype.m_IntGenotype.push_back(nextPosition);
        visited.push_back(nextPosition);
        currentPosition = nextPosition;
    }

    auto *newAnt = m_Initialization.CreateSOIndividual(problemEncoding, newGenotype);
    m_Problem.Evaluate(*newAnt);
    CAggregatedFitness::CountFitness(*newAnt, m_ObjectiveWeights);

    m_Population.push_back(newAnt);
}


void CACO_TSP::LeavePheromone() {
    // Find min and max evaluation for normalization
    float maxEvaluation = std::numeric_limits<float>::min();
    float minEvaluation = std::numeric_limits<float>::max();
    for (auto *ant: m_Population) {
        float evaluation = ant->m_Fitness;
        if (evaluation > maxEvaluation) {
            maxEvaluation = evaluation;
        }
        if (evaluation < minEvaluation) {
            minEvaluation = evaluation;
        }
    }

    // Add normalized pheromone to the pheromone path
    for (auto *ant: m_Population) {
        float evaluation = ant->m_Fitness;
        float pheromone_delta = (evaluation - minEvaluation) / (maxEvaluation - minEvaluation);

        auto sequence = ant->m_Genotype.m_IntGenotype;
        for (int i = 0; i < sequence.size() - 1; i++) {
            float distance = m_DistanceMatrix[sequence[i]][sequence[i + 1]];
            pheromone_delta /= distance;
            m_PheromoneMap[sequence[i]][sequence[i + 1]] += pheromone_delta;
            m_PheromoneMap[sequence[i + 1]][sequence[i]] += pheromone_delta;
        }
        m_PheromoneMap[sequence[sequence.size() - 1]][sequence[0]] += pheromone_delta;
        m_PheromoneMap[sequence[0]][sequence[sequence.size() - 1]] += pheromone_delta;
    }

    // Reduce pheromone on all paths
    auto size = m_Population[0]->m_Genotype.m_IntGenotype.size();
    for (int i = 0; i < size; i++) {
        for (int ii = i + 1; ii < size; ii++) {
            m_PheromoneMap[i][ii] *= m_ReducingMultiplier;
            m_PheromoneMap[ii][i] = m_PheromoneMap[i][ii];
        }
    }
}

SSOIndividual* CACO_TSP::GetRandomAnt(){
    SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
    auto* newAnt = m_Initialization.CreateSOIndividual(problemEncoding);

    m_Problem.Evaluate(*newAnt);
    CAggregatedFitness::CountFitness(*newAnt, m_ObjectiveWeights);

    return newAnt;
}

void CACO_TSP::RandomAnts() {
    for (size_t i = 0; i < m_PopulationSize; ++i) {
        auto newAnt= GetRandomAnt();
        m_Population.push_back(newAnt);
    }
}

void CACO_TSP::AntMarch() {
    SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
    SGenotype newGenotype;

    auto numberOfCities = problemEncoding.m_Encoding[0].m_SectionDescription.size();
    auto randomStart = CRandom::GetInt(0, numberOfCities);
    newGenotype.m_IntGenotype.push_back(randomStart);
    auto currentPosition = randomStart;
    std::vector<int> visited;
    visited.push_back(currentPosition);


    float conformism = CRandom::GetFloat(0, 1);

    for (int i = 1; i < numberOfCities; i++) {
        std::vector<std::pair<int, float>> best_routes;
        for (int ii = 0; ii < numberOfCities; ii++) {
            auto found_element = std::find(visited.begin(), visited.end(), ii);
            if (found_element != visited.end()) {
                continue;
            }
            if (ii == currentPosition) {
                continue;
            }
            best_routes.emplace_back(
                    ii, m_PheromoneMap[currentPosition][ii]
            );
        }
        std::sort(best_routes.begin(), best_routes.end(),
                  [](const std::pair<int, float> &a, const std::pair<int, float> &b) {
                      return a.second > b.second;
                  });

        float probability = 0.8;
        int nextPosition = best_routes[0].first;
        for (auto pair: best_routes) {
            if (conformism < probability) {
                nextPosition = pair.first;
                break;
            }
            probability+=0.1;
        }

        newGenotype.m_IntGenotype.push_back(nextPosition);
        visited.push_back(nextPosition);
        currentPosition = nextPosition;
    }


    auto *newAnt = m_Initialization.CreateSOIndividual(problemEncoding, newGenotype);
    m_Problem.Evaluate(*newAnt);
    CAggregatedFitness::CountFitness(*newAnt, m_ObjectiveWeights);

    m_Population.push_back(newAnt);

}

void CACO_TSP::RunAnts() {
    int bestAntPosition=-1;
    for (int i=0; i<m_PopulationSize;i++) {
        if (m_Population[i]->m_Fitness < m_GloballyBest->m_Fitness) {
            bestAntPosition = i;
        }
    }
    if(bestAntPosition!=-1){
        m_GloballyBest=m_Population[bestAntPosition];
        m_Population[bestAntPosition]= nullptr;
    }

    ASOMethod::Reset();
    for (size_t i = 0; i < m_PopulationSize; ++i) {
        AntMarch();
    }
}

void CACO_TSP::ResetPheromoneMap(){
    size_t numberOfCities = m_Problem.GetProblemEncoding().m_Encoding[0].m_SectionDescription.size();
    m_PheromoneMap = std::vector<std::vector<float>>(numberOfCities, std::vector<float>(numberOfCities, 0.0));

    m_DistanceMatrix = m_Problem.GetProblemEncoding().m_additionalProblemData;

    for(int i=0;i< m_PheromoneMap.size();i++){
        for(int ii=0;ii< m_PheromoneMap.size();ii++){
            if(i == ii ){
                m_PheromoneMap[i][ii]=0;
            }else{
                switch(m_InitType){
                    case Uniform:
                        m_PheromoneMap[i][ii]=1;
                    case Distance:
                        m_PheromoneMap[i][ii]=1/m_DistanceMatrix[i][ii];
                    default:
                        m_PheromoneMap[i][ii]=1;

                }
            }
        }
    }

}

void CACO_TSP::AddExperimentData(int generation) {
    SSOIndividual *best = *std::min_element(m_Population.begin(), m_Population.end(),
                                            [](const auto &a, const auto &b) {
                                                return a->m_Fitness < b->m_Fitness;
                                            });
    SSOIndividual *worst = *std::max_element(m_Population.begin(), m_Population.end(),
                                             [](const auto &a, const auto &b) {
                                                 return a->m_Fitness < b->m_Fitness;
                                             });

    float totalFitness = 0.0;
    for (const auto &individual: m_Population) {
        totalFitness += individual->m_Fitness;
    }
    float meanFitness = totalFitness / float(m_Population.size());

    std::string generationData = std::to_string(generation) + ';' +
                                 std::to_string(best->m_Fitness) + ';' +
                                 std::to_string(worst->m_Fitness) + ';' +
                                 std::to_string(meanFitness);
    CExperimentLogger::AddLine(generationData.c_str());
}

void CACO_TSP::LogResultData() {
    SSOIndividual *best = *std::min_element(m_Population.begin(), m_Population.end(),
                                            [](const auto &a, const auto &b) {
                                                return a->m_Fitness < b->m_Fitness;
                                            });
    CExperimentLogger::LogResult(std::to_string(best->m_Fitness).c_str());
}






optimizer\src\method\methods\SO\DEGR\CDE.cpp
=============
#include "CDE.h"

#include "../../../../utils/random/CRandom.h"
#include "../utils/experiment/CSOExperimentUtils.h"
#include "../utils/aggregatedFitness/CAggregatedFitness.h"
#include "../../../../utils/logger/ErrorUtils.h"
#include <numeric>

CDE::CDE(
        std::vector<float>& objectiveWeights,
        AProblem& evaluator,
        AInitialization& initialization,
        SConfigMap* configMap
) : ASOMethod(evaluator, initialization, objectiveWeights)
{
    configMap->TakeValue("PopulationSize", m_PopulationSize);
    m_Population.reserve(m_PopulationSize);
    ErrorUtils::LowerThanZeroI("DE", "PopulationSize", m_PopulationSize);

    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    ErrorUtils::LowerThanZeroI("DE", "GenerationLimit", m_GenerationLimit);

    configMap->TakeValue("Cr", m_Cr);
    ErrorUtils::OutOfScopeF("DE", "Cr", m_Cr);
        
    configMap->TakeValue("F", m_F);
    ErrorUtils::OutOfScopeF("DE", "F", m_F);
}

void CDE::RunOptimization()
{
    int generation = 0;

    for (size_t i = 0; i < m_PopulationSize; ++i)
    {
        CreateIndividual();
    }

    CSOExperimentUtils::AddExperimentData(generation, m_Population);

    while (generation < m_GenerationLimit)
    {
        EvolveToNextGeneration();
        CSOExperimentUtils::AddExperimentData(generation, m_Population);
        generation++;
    }
    auto* best = CSOExperimentUtils::FindBest(m_Population);
    CSOExperimentUtils::LogResultData(*best, m_Problem);
}

void CDE::CreateIndividual()
{
    SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
    auto* newInd = m_Initialization.CreateSOIndividual(problemEncoding);

    m_Problem.Evaluate(*newInd);
    CAggregatedFitness::CountFitness(*newInd, m_ObjectiveWeights);

    m_Population.push_back(newInd);
}

void CDE::EvolveToNextGeneration()
{
    for (int i = 0; i < m_PopulationSize; i++)
    {
        auto* donor = new SSOIndividual(*m_Population[i]);
        std::vector<int> indices(m_Population.size());
        std::iota(indices.begin(), indices.end(), 0);
        CRandom::Shuffle(0, indices.size(), indices);
        auto& random1 = m_Population[indices[0]]->m_Genotype;
        auto& random2 = m_Population[indices[1]]->m_Genotype;
        auto& random3 = m_Population[indices[2]]->m_Genotype;

        DifferentialEvolutionStep(donor->m_Genotype, random1, random2, random3);
        m_Problem.Evaluate(*donor);
        CAggregatedFitness::CountFitness(*donor, m_ObjectiveWeights);

        if (donor->m_Fitness < m_Population[i]->m_Fitness)
        {
            delete m_Population[i];
            m_Population[i] = donor;
        }
        else
        {
            delete donor;
        }
    }
}

void CDE::DifferentialEvolutionStep(SGenotype& donor, const SGenotype& gens1, const SGenotype& gens2, const SGenotype& gens3)
{
    size_t sectionStartIndex = 0;
    for (const auto& encodingSection: m_Problem.GetProblemEncoding().m_Encoding)
    {
        const auto& sectionDesc = encodingSection.m_SectionDescription;
        const size_t sectionSize = sectionDesc.size();
        switch (encodingSection.m_SectionType)
        {
            case EEncodingType::ASSOCIATION:
            {
                for (size_t j = 0; j < encodingSection.m_SectionDescription.size(); ++j)
                {
                    if (CRandom::GetFloat(0, 1) < m_Cr)
                    {
                        size_t g = sectionStartIndex + j;
                        donor.m_FloatGenotype[g] = gens1.m_FloatGenotype[g] + m_F * (gens2.m_FloatGenotype[g] - gens3.m_FloatGenotype[g]);
                        // Check constraints, use random if out of bounds
                        if (donor.m_FloatGenotype[g] < sectionDesc[j].m_MinValue || donor.m_FloatGenotype[g] >= sectionDesc[j].m_MaxValue)
                        {
                            donor.m_FloatGenotype[g] = CRandom::GetFloat(sectionDesc[j].m_MaxValue, sectionDesc[j].m_MinValue);
                        }
                    }
                }
                break;
            }
        }
        sectionStartIndex += sectionSize;
    }
}


optimizer\src\method\methods\SO\GA\CGA.cpp
=============

#include "CGA.h"
#include "../utils/aggregatedFitness/CAggregatedFitness.h"
#include "../utils/experiment/CSOExperimentUtils.h"
#include "../../../../utils/logger/ErrorUtils.h"

CGA::CGA(
        std::vector<float> &objectiveWeights,
        AProblem &evaluator,
        AInitialization &initialization,
        CFitnessTournament &fitnessTournament,
        ACrossover &crossover,
        AMutation &mutation,
        SConfigMap *configMap
) : ASOGeneticMethod(evaluator, initialization, crossover, mutation, objectiveWeights),
    m_FitnessTournament(fitnessTournament)
{
    configMap->TakeValue("PopulationSize", m_PopulationSize);
    m_Population.reserve(m_PopulationSize);
    ErrorUtils::LowerThanZeroI("GA", "PopulationSize", m_PopulationSize);

    configMap->TakeValue("GenerationLimit", m_GenerationLimit);
    ErrorUtils::LowerThanZeroI("GA", "GenerationLimit", m_GenerationLimit);
}

void CGA::RunOptimization()
{
    int generation = 0;

    for (size_t i = 0; i < m_PopulationSize; ++i)
    {
        CreateIndividual();
    }

    CSOExperimentUtils::AddExperimentData(generation, m_Population);

    while (generation < m_GenerationLimit)
    {
        EvolveToNextGeneration();
        CSOExperimentUtils::AddExperimentData(generation, m_Population);
        generation++;
    }

    auto* best = CSOExperimentUtils::FindBest(m_Population);
    CSOExperimentUtils::LogResultData(*best, m_Problem);
}

void CGA::CreateIndividual()
{
    SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
    auto* newInd = m_Initialization.CreateSOIndividual(problemEncoding);

    m_Problem.Evaluate(*newInd);
    CAggregatedFitness::CountFitness(*newInd, m_ObjectiveWeights);

    m_Population.push_back(newInd);
}

void CGA::EvolveToNextGeneration()
{
    std::vector<SSOIndividual *> children;
    children.reserve(m_PopulationSize);

    for (size_t i = 0; i < m_PopulationSize; i += 2)
    {
        auto* firstParent = m_FitnessTournament.Select(m_Population);
        auto* secondParent = m_FitnessTournament.Select(m_Population);

        auto* firstChild = new SSOIndividual{*firstParent};
        auto* secondChild = new SSOIndividual{*secondParent};

        m_Crossover.Crossover(
                m_Problem.GetProblemEncoding(),
                *firstParent,
                *secondParent,
                *firstChild,
                *secondChild
        );

        m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *firstChild);
        m_Mutation.Mutate(m_Problem.GetProblemEncoding(), *secondChild);

        m_Problem.Evaluate(*firstChild);
        CAggregatedFitness::CountFitness(*firstChild, m_ObjectiveWeights);
        m_Problem.Evaluate(*secondChild);
        CAggregatedFitness::CountFitness(*secondChild, m_ObjectiveWeights);

        children.emplace_back(firstChild);
        children.emplace_back(secondChild);
    }

    for (auto& i: m_Population)
    {
        delete i;
    }

    m_Population.clear();
    m_Population.swap(children);
}

optimizer\src\method\methods\SO\PSO\CPSO.cpp
=============
#include <algorithm>
#include "CPSO.h"
#include "../../../../utils/random/CRandom.h"
#include "../utils/experiment/CSOExperimentUtils.h"
#include "../../../../utils/logger/ErrorUtils.h"

CPSO::CPSO(std::vector<float>& objectiveWeights, AProblem& evaluator, AInitialization& initialization, SConfigMap* configMap)
        : ASOMethod(evaluator, initialization, objectiveWeights)
{
    configMap->TakeValue("SwarmSize", m_SwarmSize);
    ErrorUtils::LowerThanZeroI("PSO", "SwarmSize", m_SwarmSize);
    m_Swarm.reserve(m_SwarmSize);

    configMap->TakeValue("InertiaWeight", m_InertiaWeight);
    ErrorUtils::OutOfScopeF("PSO", "InertiaWeight", m_InertiaWeight);

    configMap->TakeValue("CognitiveCoefficient", m_CognitiveCoefficient);
    ErrorUtils::OutOfScopeF("PSO", "CognitiveCoefficient", m_CognitiveCoefficient);

    configMap->TakeValue("SocialCoefficient", m_SocialCoefficient);
    ErrorUtils::OutOfScopeF("PSO", "SocialCoefficient", m_SocialCoefficient);

    configMap->TakeValue("MigrationThreshold", m_MigrationThreshold);
    ErrorUtils::LowerThanZeroF("PSO", "MigrationThreshold", m_MigrationThreshold);

    configMap->TakeValue("IterationLimit", m_IterationLimit);
    ErrorUtils::LowerThanZeroI("PSO", "IterationLimit", m_IterationLimit);
}


void CPSO::RunOptimization()
{
    int iteration = 0;
    
    m_BestKnownFitness = std::numeric_limits<float>::max();

    for (size_t i = 0; i < m_SwarmSize; ++i)
    {
        SParticle* prt = CreateParticle();

        if (prt->m_Fitness < m_BestKnownFitness)
        {
            m_BestKnownFitness = prt->m_Fitness;
            m_BestKnownPosition = prt->m_BestKnownPosition;
        }
    }

    int migrationCounter = 0;

    while (iteration < m_IterationLimit)
    {
        float previousBestKnownFitness = m_BestKnownFitness;
        MoveParticles();
        if (previousBestKnownFitness >= m_BestKnownFitness)
            migrationCounter++;
        if (m_MigrationThreshold > 0 && migrationCounter > m_MigrationThreshold)
        {
            Migrate();
            migrationCounter = 0;
        }

        CSOExperimentUtils::AddExperimentData(iteration, m_Swarm);
        iteration++;
    }

    auto* best = CSOExperimentUtils::FindBest(m_Swarm);
    CSOExperimentUtils::LogResultData(*best, m_Problem);
}

void CPSO::UpdatePosition(std::vector<float>& position, std::vector<float>& velocity)
{
    std::vector<SEncodingDescriptor> sectionDescription = m_Problem.GetProblemEncoding().m_Encoding[0].m_SectionDescription;

    for (size_t i = 0; i < position.size(); ++i)
    {
        float dimension = position[i] + velocity[i];
        dimension = std::max(dimension, sectionDescription[i].m_MinValue);
        dimension = std::min(dimension, 0.9999999f * sectionDescription[i].m_MaxValue);
        position[i] = dimension;
    }
}

void CPSO::UpdateBests(SParticle* particle)
{
    if (particle->m_Fitness < particle->m_BestKnownFitness)
    {
        particle->m_BestKnownPosition = particle->m_Genotype.m_FloatGenotype;
        particle->m_BestKnownFitness = particle->m_Fitness;

        if (particle->m_BestKnownFitness < m_BestKnownFitness)
        {
            m_BestKnownPosition = particle->m_BestKnownPosition;
            m_BestKnownFitness = particle->m_BestKnownFitness;
        }
    }
}

void CPSO::Migrate()
{
    for (size_t i = 0; i < m_SwarmSize; ++i)
    {
        for (size_t j = 0; j < m_Swarm[i]->m_Genotype.m_FloatGenotype.size(); ++j)
        {
            float dimension = m_Problem.GetProblemEncoding().m_Encoding[0].m_SectionDescription[j].m_MaxValue * 0.9999999f - m_Swarm[i]->m_Genotype.m_FloatGenotype[j];
            m_Swarm[i]->m_Genotype.m_FloatGenotype[j] = dimension;
        }

        m_Problem.Evaluate(*m_Swarm[i]);
        CAggregatedFitness::CountFitness(*m_Swarm[i], m_ObjectiveWeights);

        UpdateBests(m_Swarm[i]);
    }
}

SParticle* CPSO::CreateParticle()
{
    SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
    auto* newPart = m_Initialization.CreateParticle(problemEncoding);

    m_Problem.Evaluate(*newPart);
    newPart->m_BestKnownPosition = newPart->m_Genotype.m_FloatGenotype;
    CAggregatedFitness::CountFitness(*newPart, m_ObjectiveWeights);
    newPart->m_BestKnownFitness = newPart->m_Fitness;

    m_Swarm.push_back(newPart);

    return newPart;
}

void CPSO::InitVelocity(SProblemEncoding& problemEncoding, std::vector<float> *newVelocity) const
{
    for (const SEncodingSection& encodingSection : problemEncoding.m_Encoding)
    {
        switch (encodingSection.m_SectionType)
        {
            case EEncodingType::ASSOCIATION:
            {
                for (const SEncodingDescriptor& encDesc : encodingSection.m_SectionDescription)
                {
                    newVelocity->push_back(CRandom::GetFloat(encDesc.m_MinValue, encDesc.m_MaxValue));
                }
                break;
            }
        }
    }
}

void CPSO::MoveParticles()
{
    std::vector<SEncodingDescriptor> sectionDescription = m_Problem.GetProblemEncoding().m_Encoding[0].m_SectionDescription;

    for (size_t i = 0; i < m_SwarmSize; ++i)
    {
        for (size_t j = 0; j < m_Swarm[i]->m_Velocity.size(); ++j)
        {
            float rp = CRandom::GetFloat(0, 1);
            float p = m_Swarm[i]->m_BestKnownPosition[j];
            float rg = CRandom::GetFloat(0, 1);
            float g = m_BestKnownPosition[j];
            float x = m_Swarm[i]->m_Genotype.m_FloatGenotype[j];
            float v = m_Swarm[i]->m_Velocity[j];

            float dimension =
                m_InertiaWeight * m_Swarm[i]->m_Velocity[j]
                + m_CognitiveCoefficient * rp * (p - x)
                + m_SocialCoefficient * rg * (g - x);

            m_Swarm[i]->m_Velocity[j] = std::max(dimension, (sectionDescription[j].m_MinValue - sectionDescription[j].m_MaxValue) * 0.9999999f);
            m_Swarm[i]->m_Velocity[j] = std::min(dimension, (sectionDescription[j].m_MaxValue - sectionDescription[j].m_MinValue) * 0.9999999f);
        }

        UpdatePosition(m_Swarm[i]->m_Genotype.m_FloatGenotype, m_Swarm[i]->m_Velocity);
        m_Problem.Evaluate(*m_Swarm[i]);
        CAggregatedFitness::CountFitness(*m_Swarm[i], m_ObjectiveWeights);

        UpdateBests(m_Swarm[i]);
    }
}

optimizer\src\method\methods\SO\SA\CSA.cpp
=============
#include "CSA.h"
#include "../../../../utils/logger/CExperimentLogger.h"
#include "../utils/aggregatedFitness/CAggregatedFitness.h"
#include "../../../../utils/random/CRandom.h"
#include "../utils/experiment/CSOExperimentUtils.h"
#include "../../../../utils/logger/ErrorUtils.h"
#include <cmath>

CSA::CSA(std::vector<float>& objectiveWeights, AProblem& evaluator, AInitialization& initialization,
         SConfigMap* configMap)
        : ASOMethod(evaluator, initialization, objectiveWeights)
{
    configMap->TakeValue("InitialTemperature", m_InitialTemperature);
    ErrorUtils::LowerThanZeroF("SA", "InitialTemperature", m_InitialTemperature);

    configMap->TakeValue("FinalTemperature", m_FinalTemperature);
    ErrorUtils::LowerThanZeroF("SA", "FinalTemperature", m_FinalTemperature);

    configMap->TakeValue("CoolingRate", m_CoolingRate);
    ErrorUtils::OutOfScopeF("SA", "CoolingRate", m_CoolingRate);
}


void CSA::RunOptimization()
{
    double temperature = m_InitialTemperature;
    
    InitializeSolution();

    while (temperature > m_FinalTemperature)
    {
        Iterate(temperature);
        CExperimentLogger::AddLine((std::to_string(temperature) + ";" + std::to_string(m_CurrentSolution->m_Fitness)).c_str());
        temperature *= m_CoolingRate;
    }
    
    CSOExperimentUtils::LogResultData(*m_CurrentSolution, m_Problem);
}

void CSA::InitializeSolution()
{
    SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
    m_CurrentSolution = m_Initialization.CreateSOIndividual(problemEncoding);
    m_Problem.Evaluate(*m_CurrentSolution);
    CAggregatedFitness::CountFitness(*m_CurrentSolution, m_ObjectiveWeights);
}

void CSA::Iterate(double temperature)
{
    SSOIndividual* neighborSolution = m_Initialization.CreateNeighborSolution(m_Problem.GetProblemEncoding(), *m_CurrentSolution);
    m_Problem.Evaluate(*neighborSolution);
    CAggregatedFitness::CountFitness(*neighborSolution, m_ObjectiveWeights);
    
    double delta = CAggregatedFitness::CalculateDelta(*neighborSolution, *m_CurrentSolution, m_ObjectiveWeights);

    if (delta < 0 || (exp(-delta / temperature) > CRandom::GetFloat(0.0f, 1.0f)))
    {
        delete m_CurrentSolution;
        m_CurrentSolution = neighborSolution;
    }
    else
    {
        delete neighborSolution;
    }
}

// Destructor to clean up
CSA::~CSA()
{

}


optimizer\src\method\methods\SO\TS\CTS.cpp
=============
#include "CTS.h"
#include "../../../../utils/logger/CExperimentLogger.h"
#include "../utils/aggregatedFitness/CAggregatedFitness.h"
#include "../utils/experiment/CSOExperimentUtils.h"
#include "../../../../utils/logger/ErrorUtils.h"

CTS::CTS(std::vector<float>& objectiveWeights, AProblem& evaluator, AInitialization& initialization,
         SConfigMap* configMap)
        : ASOMethod(evaluator, initialization, objectiveWeights)
{
    configMap->TakeValue("TabuListSize", m_TabuListSize);
    ErrorUtils::LowerThanZeroI("TS", "TabuListSize", m_TabuListSize);

    configMap->TakeValue("MaxIterations", m_MaxIterations);
    ErrorUtils::LowerThanZeroI("TS", "MaxIterations", m_MaxIterations);

    configMap->TakeValue("SimilarityThreshold", m_SimilarityThreshold);
    ErrorUtils::LowerThanZeroF("TS", "SimilarityThreshold", m_SimilarityThreshold);
}


void CTS::RunOptimization()
{
    InitializeSolution();
    auto bestSolution = std::make_shared<SSOIndividual>(*m_CurrentSolution);
    CAggregatedFitness::CountFitness(*bestSolution, m_ObjectiveWeights);

    for (int iteration = 0; iteration < m_MaxIterations; ++iteration)
    {
        auto newSolution = std::shared_ptr<SSOIndividual>(m_Initialization.CreateNeighborSolution(m_Problem.GetProblemEncoding(), *m_CurrentSolution));
        m_Problem.Evaluate(*newSolution);
        CAggregatedFitness::CountFitness(*newSolution, m_ObjectiveWeights);

        double delta = CAggregatedFitness::CalculateDelta(*newSolution, *m_CurrentSolution, m_ObjectiveWeights);

        if (!IsTabu(newSolution) && delta < 0)
        {
            UpdateTabuList(newSolution);
            m_CurrentSolution = newSolution;

            if (delta < CAggregatedFitness::CalculateDelta(*bestSolution, *m_CurrentSolution, m_ObjectiveWeights))
            {
                bestSolution = std::make_shared<SSOIndividual>(*m_CurrentSolution);
                CAggregatedFitness::CountFitness(*bestSolution, m_ObjectiveWeights);
            }
        }
        
        CExperimentLogger::AddLine((std::to_string(delta) + ";" + std::to_string(m_CurrentSolution->m_Fitness)).c_str());
    }

    CSOExperimentUtils::LogResultData(*m_CurrentSolution, m_Problem);
}

void CTS::InitializeSolution()
{
    SProblemEncoding& problemEncoding = m_Problem.GetProblemEncoding();
    m_CurrentSolution = std::make_shared<SSOIndividual>(*m_Initialization.CreateSOIndividual(problemEncoding));

    m_Problem.Evaluate(*m_CurrentSolution);
    CAggregatedFitness::CountFitness(*m_CurrentSolution, m_ObjectiveWeights);
}

bool CTS::IsTabu(const std::shared_ptr<SSOIndividual> candidate)
{
    for (auto tabuSolution: m_TabuList)
    {
        // Check similarity for m_FloatGenotype
        int floatSimilarityCount = 0;
        for (size_t i = 0; i < candidate->m_Genotype.m_FloatGenotype.size(); i++)
        {
            if (std::fabs(candidate->m_Genotype.m_FloatGenotype[i] - tabuSolution->m_Genotype.m_FloatGenotype[i]) < 0.01)
            {
                floatSimilarityCount++;
            }
        }
        float floatSimilarityPercentage = static_cast<float>(floatSimilarityCount) / candidate->m_Genotype.m_FloatGenotype.size();
        if (floatSimilarityPercentage > m_SimilarityThreshold) return true;

        // Check similarity for m_IntGenotype
        int intSimilarityCount = 0;
        for (size_t i = 0; i < candidate->m_Genotype.m_IntGenotype.size(); i++)
        {
            if (candidate->m_Genotype.m_IntGenotype[i] == tabuSolution->m_Genotype.m_IntGenotype[i])
            {
                intSimilarityCount++;
            }
        }
        float intSimilarityPercentage = static_cast<float>(intSimilarityCount) / candidate->m_Genotype.m_IntGenotype.size();
        if (intSimilarityPercentage > m_SimilarityThreshold) return true;

        // Check similarity for m_BoolGenotype
        int boolSimilarityCount = 0;
        for (size_t i = 0; i < candidate->m_Genotype.m_BoolGenotype.size(); i++)
        {
            if (candidate->m_Genotype.m_BoolGenotype[i] == tabuSolution->m_Genotype.m_BoolGenotype[i])
            {
                boolSimilarityCount++;
            }
        }
        float boolSimilarityPercentage = static_cast<float>(boolSimilarityCount) / candidate->m_Genotype.m_BoolGenotype.size();
        if (boolSimilarityPercentage > m_SimilarityThreshold) return true;
    }

    return false; // Candidate is not tabu
}

void CTS::UpdateTabuList(std::shared_ptr<SSOIndividual> newSolution)
{
    m_TabuList.push_back(newSolution);
    
    if (m_TabuList.size() > m_TabuListSize)
    {
        m_TabuList.pop_front();
    }
}



optimizer\src\method\methods\SO\utils\aggregatedFitness\CAggregatedFitness.cpp
=============

#include "CAggregatedFitness.h"

void CAggregatedFitness::CountFitness(SSOIndividual &individual, std::vector<float> &objectiveWeights)
{
    if (objectiveWeights.empty() || objectiveWeights.size() == 1)
    {
        individual.m_Fitness = individual.m_NormalizedEvaluation[0];
    }

    float fitness = 0.0f;
    for (int i = 0; i < objectiveWeights.size(); ++i)
    {
        fitness += individual.m_NormalizedEvaluation[i] * objectiveWeights[i];
    }

    individual.m_Fitness = fitness;
}

double CAggregatedFitness::CalculateDelta(const SSOIndividual& newSolution, const SSOIndividual& currentSolution, std::vector<float> &objectiveWeights)
{
    double delta = 0.0;
    for (size_t i = 0; i < newSolution.m_NormalizedEvaluation.size(); ++i)
    {
        double weight = (i < objectiveWeights.size()) ? objectiveWeights[i] : 1.0;
        delta += weight * (newSolution.m_NormalizedEvaluation[i] - currentSolution.m_NormalizedEvaluation[i]);
    }
    return delta;
}

optimizer\src\method\methods\SO\utils\experiment\CSOExperimentUtils.cpp
=============
#include "CSOExperimentUtils.h"
#include "../../../../../utils/logger/CExperimentLogger.h"
#include <algorithm>
#include <string>
#include <sstream>

void CSOExperimentUtils::AddExperimentData(const int generation, const std::vector<SSOIndividual*>& population)
{
    auto* best = *std::min_element(population.begin(), population.end(),
                                            [](const auto &a, const auto &b)
                                            {
                                                return a->m_Fitness < b->m_Fitness;
                                            });
    auto* worst = *std::max_element(population.begin(), population.end(),
                                             [](const auto &a, const auto &b)
                                             {
                                                 return a->m_Fitness < b->m_Fitness;
                                             });

    float totalFitness = 0.0;
    for (const auto& individual: population)
    {
        totalFitness += individual->m_Fitness;
    }
    float meanFitness = totalFitness / float(population.size());

    std::string generationData = std::to_string(generation) + ';' +
                                 std::to_string(best->m_Fitness) + ';' +
                                 std::to_string(worst->m_Fitness) + ';' +
                                 std::to_string(meanFitness);
    CExperimentLogger::AddLine(generationData.c_str());
}

void CSOExperimentUtils::AddExperimentData(int generation, const std::vector<SParticle *> &swarm)
{
    auto* best = *std::min_element(swarm.begin(), swarm.end(),
                                   [](const auto &a, const auto &b)
                                   {
                                       return a->m_Fitness < b->m_Fitness;
                                   });
    auto* worst = *std::max_element(swarm.begin(), swarm.end(),
                                    [](const auto &a, const auto &b)
                                    {
                                        return a->m_Fitness < b->m_Fitness;
                                    });

    float totalFitness = 0.0;
    for (const auto& individual: swarm)
    {
        totalFitness += individual->m_Fitness;
    }
    float meanFitness = totalFitness / float(swarm.size());

    std::string generationData = std::to_string(generation) + ';' +
                                 std::to_string(best->m_Fitness) + ';' +
                                 std::to_string(worst->m_Fitness) + ';' +
                                 std::to_string(meanFitness);
    CExperimentLogger::AddLine(generationData.c_str());
}

SSOIndividual* CSOExperimentUtils::FindBest(const std::vector<SSOIndividual *> &population)
{
    return *std::min_element(population.begin(), population.end(),
                      [](const auto &a, const auto &b)
                      {
                          return a->m_Fitness < b->m_Fitness;
                      });
}

SSOIndividual* CSOExperimentUtils::FindBest(const std::vector<SParticle *> &swarm)
{
    return *std::min_element(swarm.begin(), swarm.end(),
                             [](const auto &a, const auto &b)
                             {
                                 return a->m_Fitness < b->m_Fitness;
                             });
}

void CSOExperimentUtils::LogResultData(SSOIndividual& best, AProblem& problem)
{
    CExperimentLogger::LogData();

    std::string header = "Fitness;NormalizedEvaluation";
    std::string resultString = BestToCSVString(best);

    //CExperimentLogger::LogResult(header.c_str());
    CExperimentLogger::LogResult(resultString.c_str());
    problem.LogSolution(best);
}

std::string CSOExperimentUtils::BestToCSVString(const SSOIndividual &best)
{
    std::ostringstream oss;
    oss << best.m_Fitness; // Append the fitness

    // Append each element of the evaluation vector
    for (const auto& value : best.m_NormalizedEvaluation) {
        oss << ";" << value;
    }

    return oss.str();
}


optimizer\src\method\operators\crossover\crossovers\CCVRP_OX.cpp
=============
#include "utils/random/CRandom.h"
#include <algorithm>
#include "CCVRP_OX.h"
#include <climits>

void CCVRP_OX::FixChild(AIndividual &child)
{
    auto &childGenes = child.m_Genotype.m_IntGenotype;
    auto size = child.m_Genotype.m_IntGenotype.size();

    std::vector<int> all_genes(size);
    for (int i = 0; i < child.m_Genotype.m_IntGenotype.size(); i++)
    {
        all_genes[i] = i;
    }

    std::vector<int> missing_genes;
    for (auto gene: all_genes)
    {
        if (std::count(childGenes.begin(), childGenes.end(), gene) < 1)
        {
            missing_genes.push_back(gene);
        }
    }

    int ii = 0;
    for (size_t i = 0; i < childGenes.size(); ++i)
    {
        int gene = childGenes[i];

        if (std::count(childGenes.begin(), childGenes.end(), gene) > 1)
        {
            auto it = std::find(all_genes.begin(), all_genes.end(), gene);

            if (it != all_genes.end())
            {
                size_t index = std::distance(childGenes.begin(), it);
                child.m_Genotype.m_IntGenotype[i] = missing_genes[ii];
                ii++;
            }
        }
    }

    missing_genes.clear();
    for (auto gene: all_genes)
    {
        if (std::count(childGenes.begin(), childGenes.end(), gene) < 1)
        {
            missing_genes.push_back(gene);
        }
    }
}

void CCVRP_OX::Crossover(const SProblemEncoding& problemEncoding, AIndividual &firstParent, AIndividual &secondParent,
                         AIndividual &firstChild, AIndividual &secondChild)
 {
    for (const SEncodingSection &encoding: problemEncoding.m_Encoding)
    {
        const size_t sectionSize = encoding.m_SectionDescription.size();
        const auto &secondParentGenes = secondParent.m_Genotype;
        const auto &firstParentGenes = firstParent.m_Genotype;

        // Order Crossover (OX1)
        if (CRandom::GetFloat(0, 1) < m_CrossoverProbability)
        {
            int a = CRandom::GetInt(0, int(sectionSize) - 1);
            int b = CRandom::GetInt(0, int(sectionSize) - a) + a;

            std::fill(firstChild.m_Genotype.m_IntGenotype.begin(), firstChild.m_Genotype.m_IntGenotype.end(), -1);
            std::fill(secondChild.m_Genotype.m_IntGenotype.begin(), secondChild.m_Genotype.m_IntGenotype.end(), -1);

            // Copy the selected range from the parents to the children
            std::copy(firstParentGenes.m_IntGenotype.begin() + a, firstParentGenes.m_IntGenotype.begin() + b,
                      secondChild.m_Genotype.m_IntGenotype.begin() + a);
            std::copy(secondParentGenes.m_IntGenotype.begin() + a, secondParentGenes.m_IntGenotype.begin() + b,
                      firstChild.m_Genotype.m_IntGenotype.begin() + a);

            // Update remaining positions in children using the order of the other parent
            int firstChildIdx = (b == sectionSize) ? 0 : b;
            int secondChildIdx = (b == sectionSize) ? 0 : b;

            for (int i = 0; i < sectionSize; ++i)
            {
                if (i < a || i >= b)
                {
                    while (std::find(firstChild.m_Genotype.m_IntGenotype.begin(),
                                     firstChild.m_Genotype.m_IntGenotype.end(),
                                     secondParentGenes.m_IntGenotype[firstChildIdx]) !=
                           firstChild.m_Genotype.m_IntGenotype.end() && secondParentGenes.m_IntGenotype[firstChildIdx] != INT_MAX)
                    {
                        firstChildIdx = (firstChildIdx + 1) % sectionSize;
                    }
                    firstChild.m_Genotype.m_IntGenotype[i] = secondParentGenes.m_IntGenotype[firstChildIdx];
                    firstChildIdx = (firstChildIdx + 1) % sectionSize;

                    while (std::find(secondChild.m_Genotype.m_IntGenotype.begin(),
                                     secondChild.m_Genotype.m_IntGenotype.end(),
                                     firstParentGenes.m_IntGenotype[secondChildIdx]) !=
                           secondChild.m_Genotype.m_IntGenotype.end() && firstParentGenes.m_IntGenotype[secondChildIdx] != INT_MAX)
                    {
                        secondChildIdx = (secondChildIdx + 1) % sectionSize;
                    }
                    secondChild.m_Genotype.m_IntGenotype[i] = firstParentGenes.m_IntGenotype[secondChildIdx];
                    secondChildIdx = (secondChildIdx + 1) % sectionSize;
                }
            }
        }
    }
}


optimizer\src\method\operators\crossover\crossovers\CTTP_OS_SX.cpp
=============
#include "CTTP_OS_SX.h"
#include "../../../../utils/random/CRandom.h"
#include <algorithm>

void CTTP_OS_SX::Crossover(const SProblemEncoding& problemEncoding, AIndividual &firstParent, AIndividual &secondParent,
                           AIndividual &firstChild, AIndividual &secondChild)
{
    for (const SEncodingSection &encoding: problemEncoding.m_Encoding)
    {
        const size_t sectionSize = encoding.m_SectionDescription.size();
        const auto &secondParentGenes = secondParent.m_Genotype;
        const auto &firstParentGenes = firstParent.m_Genotype;
        if (encoding.m_SectionType == EEncodingType::PERMUTATION)
        {
            // Route Crossover
            if (CRandom::GetFloat(0, 1) < m_RouteCrProb)
            {
                int a = CRandom::GetInt(0, int(sectionSize) - 1);
                int b = CRandom::GetInt(0, int(sectionSize) - a) + a;

                const auto &firstParentA = firstParentGenes.m_IntGenotype.begin() + a;
                const auto &firstParentB = firstParentGenes.m_IntGenotype.begin() + b;
                const auto &secParentA = secondParentGenes.m_IntGenotype.begin() + a;
                const auto &secParentB = secondParentGenes.m_IntGenotype.begin() + b;

                size_t firstSeekIdx = b;
                size_t secSeekIdx = b;

                for (size_t i = b; i != a; i = (i + 1) % sectionSize)
                {
                    // Update first child
                    while (std::find(firstParentA, firstParentB, secondParentGenes.m_IntGenotype[secSeekIdx]) !=
                           firstParentB)
                    {
                        secSeekIdx = (secSeekIdx + 1) % sectionSize;
                    }
                    firstChild.m_Genotype.m_IntGenotype[i] = secondParentGenes.m_IntGenotype[secSeekIdx];
                    secSeekIdx = (secSeekIdx + 1) % sectionSize;


                    // Update second child
                    while (std::find(secParentA, secParentB, firstParentGenes.m_IntGenotype[firstSeekIdx]) !=
                           secParentB)
                    {
                        firstSeekIdx = (firstSeekIdx + 1) % sectionSize;
                    }
                    secondChild.m_Genotype.m_IntGenotype[i] = firstParentGenes.m_IntGenotype[firstSeekIdx];
                    firstSeekIdx = (firstSeekIdx + 1) % sectionSize;
                }
            }
        }
        else if (encoding.m_SectionType == EEncodingType::BINARY)
        {
            // Knapsack Crossover
            if (CRandom::GetFloat(0, 1) < m_KnapCrProb)
            {
                size_t point = CRandom::GetInt(0, int(sectionSize));

                for (size_t g = 0; g < sectionSize; ++g)
                {
                    if (g < point)
                    {
                        firstChild.m_Genotype.m_BoolGenotype[g] = firstParentGenes.m_BoolGenotype[g];
                        secondChild.m_Genotype.m_BoolGenotype[g] = secondParentGenes.m_BoolGenotype[g];
                    }
                    else
                    {
                        firstChild.m_Genotype.m_BoolGenotype[g] = secondParentGenes.m_BoolGenotype[g];
                        secondChild.m_Genotype.m_BoolGenotype[g] = firstParentGenes.m_BoolGenotype[g];
                    }
                }
            }
        }
    }
}


optimizer\src\method\operators\crossover\crossovers\CUniformCX.cpp
=============
#include "CUniformCX.h"
#include "../../../../utils/random/CRandom.h"

void CUniformCX::Crossover(const SProblemEncoding& problemEncoding, AIndividual &firstParent, AIndividual &secondParent,
                           AIndividual &firstChild,
                           AIndividual &secondChild)
{
    const size_t sectionSize = problemEncoding.m_Encoding[0].m_SectionDescription.size();
    if (CRandom::GetFloat(0.0f, 1.0f) < m_CrossoverProbability)
    {
        for (size_t g = 0; g < sectionSize; ++g)
        {
            if (CRandom::GetFloat(0.0f, 1.0f) < 0.5f)
            {
                firstChild.m_Genotype.m_FloatGenotype[g] = secondParent.m_Genotype.m_FloatGenotype[g];
            }
            // Check explicitly both sides ??
            if (CRandom::GetFloat(0.0f, 1.0f) < 0.5f)
            {
                secondChild.m_Genotype.m_FloatGenotype[g] = firstParent.m_Genotype.m_FloatGenotype[g];
            }
        }
    }
}


optimizer\src\method\operators\initialization\initializations\CECVRPTWInitialization.cpp
=============
#include <algorithm>
#include "CECVRPTWInitialization.h"
#include "utils/random/CRandom.h"

SSOIndividual* CECVRPTWInitialization::CreateSOIndividual(SProblemEncoding &encoding)
{
    SGenotype genotype;
    InitGenotype(encoding, genotype);
    float toAdd = encoding.m_Encoding[0].m_SectionDescription[0].m_MinValue;
    float maxCustomerIndex = encoding.m_Encoding[0].m_SectionDescription[0].m_MaxValue;
    for (int i = 0; i < genotype.m_IntGenotype.size(); i++)
    {
        genotype.m_IntGenotype[i] += toAdd;
    }
    int vehicleCount = m_Problem.GetECVRPTWTemplate().GetVehicleCount() - 1;
    for (int i = 1; i <= vehicleCount; i++)
    {
        auto it = std::find(genotype.m_IntGenotype.begin(), genotype.m_IntGenotype.end(), maxCustomerIndex + i);
        *it = VEHICLE_DELIMITER;
    }
    std::vector<float> emptyEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> emptyNormalizedEvaluation(encoding.m_objectivesNumber, 0);

    return new SSOIndividual(genotype, emptyEvaluation, emptyNormalizedEvaluation);
}

SSOIndividual * CECVRPTWInitialization::CreateSOIndividual(SProblemEncoding &encoding, SGenotype &genotype)
{
    std::vector<float> emptyEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> emptyNormalizedEvaluation(encoding.m_objectivesNumber, 0);

    return new SSOIndividual(genotype, emptyEvaluation, emptyNormalizedEvaluation);
}

SMOIndividual* CECVRPTWInitialization::CreateMOIndividual(SProblemEncoding &encoding)
{
    SGenotype genotype;
    InitGenotype(encoding, genotype);
    float toAdd = encoding.m_Encoding[0].m_SectionDescription[0].m_MinValue;
    float maxCustomerIndex = encoding.m_Encoding[0].m_SectionDescription[0].m_MaxValue;
    for (int i = 0; i < genotype.m_IntGenotype.size(); i++)
    {
        genotype.m_IntGenotype[i] += toAdd;
    }
    int vehicleCount = m_Problem.GetECVRPTWTemplate().GetVehicleCount() - 1;
    for (int i = 1; i <= vehicleCount; i++)
    {
        auto it = std::find(genotype.m_IntGenotype.begin(), genotype.m_IntGenotype.end(), maxCustomerIndex + i);
        *it = VEHICLE_DELIMITER;
    }
    std::vector<float> emptyEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> emptyNormalizedEvaluation(encoding.m_objectivesNumber, 0);

    return new SMOIndividual(genotype, emptyEvaluation, emptyNormalizedEvaluation);
}

SParticle* CECVRPTWInitialization::CreateParticle(SProblemEncoding &encoding)
{
    SGenotype genotype;
    InitGenotype(encoding, genotype);
    std::vector<float> emptyEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> emptyNormalizedEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> velocity;

    return new SParticle(genotype, emptyEvaluation, emptyNormalizedEvaluation, velocity);
}

SSOIndividual* CECVRPTWInitialization::CreateNeighborSolution(SProblemEncoding &encoding, const SSOIndividual &baseSolution)
{
    auto* newSolution = new SSOIndividual(baseSolution);

    // Iterate through each encoding section of the problem
    for (auto &section: encoding.m_Encoding)
    {
        switch (section.m_SectionType)
        {
            case EEncodingType::ASSOCIATION:
            {
                int randomIndex = CRandom::GetInt(0, section.m_SectionDescription.size());
                float minVal = section.m_SectionDescription[randomIndex].m_MinValue;
                float maxVal = section.m_SectionDescription[randomIndex].m_MaxValue;
                newSolution->m_Genotype.m_FloatGenotype[randomIndex] = CRandom::GetFloat(minVal, maxVal);
                break;
            }
            case EEncodingType::PERMUTATION:
            {
                int index1 = CRandom::GetInt(0, section.m_SectionDescription.size());
                int index2 = CRandom::GetInt(0, section.m_SectionDescription.size());

                std::swap(newSolution->m_Genotype.m_IntGenotype[index1], newSolution->m_Genotype.m_IntGenotype[index2]);
                break;
            }
            case EEncodingType::BINARY:
            {
                int randomIndex = CRandom::GetInt(0, section.m_SectionDescription.size());
                newSolution->m_Genotype.m_BoolGenotype[randomIndex] = !newSolution->m_Genotype.m_BoolGenotype[randomIndex];
                break;
            }
        }
    }

    return newSolution;
}

void CECVRPTWInitialization::InitGenotype(SProblemEncoding &encoding, SGenotype &genotype) const
{
    for (const SEncodingSection &encodingSection: encoding.m_Encoding)
    {
        switch (encodingSection.m_SectionType)
        {
            case EEncodingType::ASSOCIATION:
            {
                for (const SEncodingDescriptor &encDesc: encodingSection.m_SectionDescription)
                {
                    genotype.m_FloatGenotype.push_back(CRandom::GetFloat(encDesc.m_MinValue, encDesc.m_MaxValue));
                }
                break;
            }
            case EEncodingType::PERMUTATION:
            {
                size_t sectionStart = genotype.m_IntGenotype.size();
                size_t sectionSize = encodingSection.m_SectionDescription.size();
                for (int i = 0; i < sectionSize; ++i)
                {
                    genotype.m_IntGenotype.push_back(i);
                }
                CRandom::Shuffle(int(sectionStart), int(sectionStart + sectionSize), genotype.m_IntGenotype);
                break;
            }
            case EEncodingType::BINARY:
            {
                std::generate_n(std::back_inserter(genotype.m_BoolGenotype),
                                encodingSection.m_SectionDescription.size(),
                                []()
                                { return CRandom::GetBool(); });
            }
        }
    }
}


optimizer\src\method\operators\initialization\initializations\CInitialization.cpp
=============
#include <algorithm>
#include "CInitialization.h"
#include "../../../../utils/random/CRandom.h"

SSOIndividual* CInitialization::CreateSOIndividual(SProblemEncoding &encoding)
{
    SGenotype genotype;
    InitGenotype(encoding, genotype);

    std::vector<float> emptyEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> emptyNormalizedEvaluation(encoding.m_objectivesNumber, 0);

    return new SSOIndividual(genotype, emptyEvaluation, emptyNormalizedEvaluation);
}

SSOIndividual *CInitialization::CreateSOIndividual(SProblemEncoding &encoding, SGenotype &genotype)
{
    std::vector<float> emptyEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> emptyNormalizedEvaluation(encoding.m_objectivesNumber, 0);

    return new SSOIndividual(genotype, emptyEvaluation, emptyNormalizedEvaluation);
}

SMOIndividual* CInitialization::CreateMOIndividual(SProblemEncoding &encoding)
{
    SGenotype genotype;
    InitGenotype(encoding, genotype);
    std::vector<float> emptyEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> emptyNormalizedEvaluation(encoding.m_objectivesNumber, 0);

    return new SMOIndividual(genotype, emptyEvaluation, emptyNormalizedEvaluation);
}

SParticle* CInitialization::CreateParticle(SProblemEncoding &encoding)
{
    SGenotype genotype;
    InitGenotype(encoding, genotype);
    std::vector<float> emptyEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> emptyNormalizedEvaluation(encoding.m_objectivesNumber, 0);
    std::vector<float> velocity;

    return new SParticle(genotype, emptyEvaluation, emptyNormalizedEvaluation, velocity);
}

SSOIndividual* CInitialization::CreateNeighborSolution(SProblemEncoding &encoding, const SSOIndividual &baseSolution)
{
    auto* newSolution = new SSOIndividual(baseSolution);

    // Iterate through each encoding section of the problem
    for (auto &section: encoding.m_Encoding)
    {
        switch (section.m_SectionType)
        {
            case EEncodingType::ASSOCIATION:
            {
                int randomIndex = CRandom::GetInt(0, section.m_SectionDescription.size());
                float minVal = section.m_SectionDescription[randomIndex].m_MinValue;
                float maxVal = section.m_SectionDescription[randomIndex].m_MaxValue;
                newSolution->m_Genotype.m_FloatGenotype[randomIndex] = CRandom::GetFloat(minVal, maxVal);
                break;
            }
            case EEncodingType::PERMUTATION:
            {
                int index1 = CRandom::GetInt(0, section.m_SectionDescription.size());
                int index2 = CRandom::GetInt(0, section.m_SectionDescription.size());

                std::swap(newSolution->m_Genotype.m_IntGenotype[index1], newSolution->m_Genotype.m_IntGenotype[index2]);
                break;
            }
            case EEncodingType::BINARY:
            {
                int randomIndex = CRandom::GetInt(0, section.m_SectionDescription.size());
                newSolution->m_Genotype.m_BoolGenotype[randomIndex] = !newSolution->m_Genotype.m_BoolGenotype[randomIndex];
                break;
            }
        }
    }

    return newSolution;
}

void CInitialization::InitGenotype(SProblemEncoding &encoding, SGenotype &genotype) const
{
    for (const SEncodingSection &encodingSection: encoding.m_Encoding)
    {
        switch (encodingSection.m_SectionType)
        {
            case EEncodingType::ASSOCIATION:
            {
                for (const SEncodingDescriptor &encDesc: encodingSection.m_SectionDescription)
                {
                    genotype.m_FloatGenotype.push_back(CRandom::GetFloat(encDesc.m_MinValue, encDesc.m_MaxValue));
                }
                break;
            }
            case EEncodingType::PERMUTATION:
            {
                size_t sectionStart = genotype.m_IntGenotype.size();
                size_t sectionSize = encodingSection.m_SectionDescription.size();
                for (int i = 0; i < sectionSize; ++i)
                {
                    genotype.m_IntGenotype.push_back(i);
                }
                CRandom::Shuffle(int(sectionStart), int(sectionStart + sectionSize), genotype.m_IntGenotype);
                break;
            }
            case EEncodingType::BINARY:
            {
                std::generate_n(std::back_inserter(genotype.m_BoolGenotype),
                                encodingSection.m_SectionDescription.size(),
                                []()
                                { return CRandom::GetBool(); });
            }
        }
    }
}


optimizer\src\method\operators\mutation\mutations\CCheapestResourceMutation.cpp
=============
#include "CCheapestResourceMutation.h"
#include "utils/random/CRandom.h"
#include "problem/problems/MSRCPSP/CMSRCPSP_TA.h"

CCheapestResourceMutation::CCheapestResourceMutation(float geneMutProb, const CMSRCPSP_TA& problemDefinition)
    : m_GeneMutProb(geneMutProb)
    , m_ProblemDefinition(problemDefinition)
{}

void CCheapestResourceMutation::Mutate(SProblemEncoding& problemEncoding, AIndividual& child)
{
    // TODO - it seems MSRCPSP uses FloatGenotype and this operator is dedicated for MSRCPSP but we should have one genotype value type
    const size_t sectionSize = problemEncoding.m_Encoding[0].m_SectionDescription.size();
    for (size_t g = 0; g < sectionSize; ++g)
    {
        if (CRandom::GetFloat(0, 1) < m_GeneMutProb)
        {
            child.m_Genotype.m_FloatGenotype[g] = m_ProblemDefinition.FindBestGeneValueCostWise(g);
        }
    }
}


optimizer\src\method\operators\mutation\mutations\CCVRPReverseFlip.cpp
=============
#include "CCVRPReverseFlip.h"
#include <algorithm>
#include "utils/random/CRandom.h"

void CCVRPReverseFlip::Mutate(SProblemEncoding& problemEncoding, AIndividual &child)
{ 
    // Route Mutation
    if (CRandom::GetFloat(0, 1) < m_ReverseMutProb)
    {
        // Use inverse mutation for cities
        int firstGene = CRandom::GetInt(0, int(child.m_Genotype.m_IntGenotype.size()));
        int secondGene = CRandom::GetInt(0, int(child.m_Genotype.m_IntGenotype.size()));

        if (firstGene < secondGene)
            std::reverse(child.m_Genotype.m_IntGenotype.begin() + firstGene,
                         child.m_Genotype.m_IntGenotype.begin() + secondGene + 1);

        else if (secondGene < firstGene)
        {
            std::reverse(child.m_Genotype.m_IntGenotype.begin() + secondGene,
                         child.m_Genotype.m_IntGenotype.begin() + firstGene + 1);
        }
    }
}

optimizer\src\method\operators\mutation\mutations\CLeastAssignedResourceMutation.cpp
=============
#include "CLeastAssignedResourceMutation.h"
#include "utils/random/CRandom.h"
#include "problem/problems/MSRCPSP/CMSRCPSP_TA.h"

CLeastAssignedResourceMutation::CLeastAssignedResourceMutation(float geneMutProb, const CMSRCPSP_TA& problemDefinition)
    : m_GeneMutProb(geneMutProb)
    , m_ProblemDefinition(problemDefinition)
{}

void CLeastAssignedResourceMutation::Mutate(SProblemEncoding& problemEncoding, AIndividual& child)
{
    // TODO - it seems MSRCPSP uses FloatGenotype and this operator is dedicated for MSRCPSP but we should have one genotype value type
    std::vector<size_t> resourcesUsage = m_ProblemDefinition.FindNumberOfResourcesUse(child.m_Genotype.m_FloatGenotype);
    const size_t sectionSize = problemEncoding.m_Encoding[0].m_SectionDescription.size();
    for (size_t g = 0; g < sectionSize; ++g)
    {
        if (CRandom::GetFloat(0, 1) < m_GeneMutProb)
        {
            // We do not recalculate the usage after each gene to keep it simple
            child.m_Genotype.m_FloatGenotype[g] = m_ProblemDefinition.FindBestGeneValueUsageWise(g, resourcesUsage);
        }
    }
}


optimizer\src\method\operators\mutation\mutations\CRandomBit.cpp
=============
#include "CRandomBit.h"
#include "utils/random/CRandom.h"

void CRandomBit::Mutate(SProblemEncoding& problemEncoding, AIndividual &child)
{
    const size_t sectionSize = problemEncoding.m_Encoding[0].m_SectionDescription.size();
    for (size_t g = 0; g < sectionSize; ++g)
    {
        if (CRandom::GetFloat(0, 1) < m_MutationProbability)
        {
            float minValue = problemEncoding.m_Encoding[0].m_SectionDescription[g].m_MinValue;
            float maxValue = problemEncoding.m_Encoding[0].m_SectionDescription[g].m_MaxValue;
            child.m_Genotype.m_FloatGenotype[g] = CRandom::GetFloat(minValue, maxValue);
        }
    }
}


optimizer\src\method\operators\mutation\mutations\CTTPReverseFlip.cpp
=============
#include <algorithm>
#include "CTTPReverseFlip.h"
#include "utils/random/CRandom.h"

void CTTPReverseFlip::Mutate(SProblemEncoding& problemEncoding, AIndividual &child)
{
    // Route Mutation
    if (CRandom::GetFloat(0, 1) < m_ReverseMutProb)
    {
        // Use inverse mutation for cities
        int firstGene = CRandom::GetInt(0, int(child.m_Genotype.m_IntGenotype.size()));
        int secondGene = CRandom::GetInt(0, int(child.m_Genotype.m_IntGenotype.size()));

        if (firstGene < secondGene)
            std::reverse(child.m_Genotype.m_IntGenotype.begin() + firstGene,
                         child.m_Genotype.m_IntGenotype.begin() + secondGene + 1);

        else if (secondGene < firstGene)
        {
            std::reverse(child.m_Genotype.m_IntGenotype.begin() + secondGene,
                         child.m_Genotype.m_IntGenotype.begin() + firstGene + 1);
        }
    }
    // Knapsack Mutation
    if (child.m_Genotype.m_BoolGenotype.size() != 0 && CRandom::GetFloat(0, 1) < m_FlipMutProb)
    {
        int randItemIdx = CRandom::GetInt(0, int(child.m_Genotype.m_BoolGenotype.size()));
        child.m_Genotype.m_BoolGenotype[randItemIdx] = !child.m_Genotype.m_BoolGenotype[randItemIdx];
    }
}


optimizer\src\method\operators\mutation\mutations\ECVRPTW\CECVRPTWRandomClientInsertion.cpp
=============
#include "CECVRPTWRandomClientInsertion.h"
#include "problem/problems/ECVRPTW/CECVRPTW.h"
#include "utils/random/CRandom.h"

CECVRPTWRandomClientInsertion::CECVRPTWRandomClientInsertion(CECVRPTW& problemDefinition)
    : m_ProblemDefinition(problemDefinition)
{}

void CECVRPTWRandomClientInsertion::Mutate(SProblemEncoding& problemEncoding, AIndividual& child)
{
	auto& genotype = child.m_Genotype.m_IntGenotype;
    auto genotypeCopy = genotype;
	std::sort(genotypeCopy.begin(), genotypeCopy.end());
	auto& problemTemplate = m_ProblemDefinition.GetECVRPTWTemplate();
	auto& allCustomers = problemTemplate.GetCustomers();

    std::vector<int> missingCustomers;
    std::set_difference(allCustomers.begin(), allCustomers.end(),
                        genotypeCopy.begin(), genotypeCopy.end(),
                        std::inserter(missingCustomers, missingCustomers.begin()));
    CRandom::Shuffle(0, missingCustomers.size(), missingCustomers);

	for (int i = 0; i < missingCustomers.size(); i++)
    {
		int customerIdx = CRandom::GetInt(0, child.m_Genotype.m_IntGenotype.size() + 1);
		child.m_Genotype.m_IntGenotype.emplace(child.m_Genotype.m_IntGenotype.begin() + customerIdx, missingCustomers[i]);
	}
}

optimizer\src\method\operators\mutation\mutations\ECVRPTW\CECVRPTWRandomClientRemoval.cpp
=============
#include "CECVRPTWRandomClientRemoval.h"
#include "problem/problems/ECVRPTW/CECVRPTW.h"
#include "utils/random/CRandom.h"

CECVRPTWRandomClientRemoval::CECVRPTWRandomClientRemoval(CECVRPTW& problemDefinition)
    : m_ProblemDefinition(problemDefinition)
{}

void CECVRPTWRandomClientRemoval::Mutate(SProblemEncoding& problemEncoding, AIndividual& child)
{
	int customersToRemove = CRandom::GetInt(1, problemEncoding.m_Encoding[0].m_SectionDescription.size() - m_ProblemDefinition.GetECVRPTWTemplate().GetVehicleCount() - 1);
	for (int i = 0; i < customersToRemove; i++)
    {
		int customerIdx = CRandom::GetInt(0, child.m_Genotype.m_IntGenotype.size());
		if (child.m_Genotype.m_IntGenotype[customerIdx] == VEHICLE_DELIMITER)
        {
			i--;
		}
		else
        {
			child.m_Genotype.m_IntGenotype.erase(child.m_Genotype.m_IntGenotype.begin() + customerIdx);
		}
	}
}

optimizer\src\method\operators\mutation\mutations\ECVRPTW\CECVRPTWShawClientInsertion.cpp
=============
#include "CECVRPTWShawClientInsertion.h"
#include "problem/problems/ECVRPTW/CECVRPTW.h"
#include "utils/random/CRandom.h"

#define DEMANDWEIGHT 0.1
#define TIMEWINDOWWEIGHT 0.6
#define DISTANCEWEIGHT 0.3

CECVRPTWShawClientInsertion::CECVRPTWShawClientInsertion(CECVRPTW& problemDefinition)
    : m_ProblemDefinition(problemDefinition)
{}

void CECVRPTWShawClientInsertion::Mutate(SProblemEncoding& problemEncoding, AIndividual& child)
{
	auto& genotype = child.m_Genotype.m_IntGenotype;
    auto genotypeCopy = genotype;
	std::sort(genotypeCopy.begin(), genotypeCopy.end());
	auto& problemTemplate = m_ProblemDefinition.GetECVRPTWTemplate();
	auto& cities = problemTemplate.GetCities();
	auto& distanceMatrix = problemTemplate.GetDistInfoMtx();
	auto& allCustomers = problemTemplate.GetCustomers();

    std::vector<int> missingCustomers;
    std::set_difference(allCustomers.begin(), allCustomers.end(),
                        genotypeCopy.begin(), genotypeCopy.end(),
                        std::inserter(missingCustomers, missingCustomers.begin()));
    CRandom::Shuffle(0, missingCustomers.size(), missingCustomers);

	for (int i = 0; i < missingCustomers.size(); i++)
    {
		auto& customerToCompare = cities[missingCustomers[i]];
		float minDistance = std::numeric_limits<float>::max();
		size_t customerWithMinDistanceIdx = -1;
		for (int j = 0; j < genotype.size(); j++)
        {
			if (genotype[j] != VEHICLE_DELIMITER)
            {
				float distanceDemand = DEMANDWEIGHT * abs(cities[genotype[j]].m_Demand - customerToCompare.m_Demand);
				float distanceTimeWindow = TIMEWINDOWWEIGHT * abs(cities[genotype[j]].m_ReadyTime - customerToCompare.m_ReadyTime);
				float distanceDistance = DISTANCEWEIGHT * distanceMatrix[missingCustomers[i]][genotype[j]].m_Distance;
				if (distanceDemand + distanceTimeWindow + distanceDistance < minDistance)
                {
					customerWithMinDistanceIdx = j;
					minDistance = distanceDemand + distanceTimeWindow + distanceDistance;
				}
			}
		}
		genotype.insert(genotype.begin() + customerWithMinDistanceIdx, missingCustomers[i]);
	}
}

optimizer\src\method\operators\mutation\mutations\ECVRPTW\CECVRPTWShawClientRemoval.cpp
=============
#include "CECVRPTWShawClientRemoval.h"
#include "problem/problems/ECVRPTW/CECVRPTW.h"
#include "utils/random/CRandom.h"

#define DEMANDWEIGHT 0.1
#define TIMEWINDOWWEIGHT 0.6
#define DISTANCEWEIGHT 0.3

CECVRPTWShawClientRemoval::CECVRPTWShawClientRemoval(CECVRPTW& problemDefinition)
    : m_ProblemDefinition(problemDefinition)
{
    // TODO - verify whether "vehicle count - 1" should be in parenthesis
    size_t indicesCount = m_ProblemDefinition.GetProblemEncoding().m_Encoding[0].m_SectionDescription.size() - m_ProblemDefinition.GetECVRPTWTemplate().GetVehicleCount() - 1;
    m_CustomerIndexes.reserve(indicesCount);
}

void CECVRPTWShawClientRemoval::Mutate(SProblemEncoding& problemEncoding, AIndividual& child) {
    m_CustomerIndexes.clear();

    // TODO - verify whether "vehicle count - 1" should be in parenthesis
	int customersToRemove = CRandom::GetInt(1, problemEncoding.m_Encoding[0].m_SectionDescription.size() - m_ProblemDefinition.GetECVRPTWTemplate().GetVehicleCount() - 1);
	int firstCustomerIdx = CRandom::GetInt(1, problemEncoding.m_Encoding[0].m_SectionDescription.size());
	auto& genotype = child.m_Genotype.m_IntGenotype;
	while (child.m_Genotype.m_IntGenotype[firstCustomerIdx] == VEHICLE_DELIMITER) {
		firstCustomerIdx = CRandom::GetInt(1, problemEncoding.m_Encoding[0].m_SectionDescription.size());
	}

	auto& problemTemplate = m_ProblemDefinition.GetECVRPTWTemplate();
	auto& cities = problemTemplate.GetCities();
	auto& distanceMatrix = problemTemplate.GetDistInfoMtx();

    m_CustomerIndexes.push_back(genotype[firstCustomerIdx]);

	genotype.erase(genotype.begin() + firstCustomerIdx);
	for (int i = 1; i < customersToRemove; i++) {
		size_t customerToCompareIdx = CRandom::GetInt(0, m_CustomerIndexes.size());
		auto& customerToCompare = cities[m_CustomerIndexes[customerToCompareIdx]];
		float minDistance = std::numeric_limits<float>::max();
		size_t customerWithMinDistanceIdx = -1;
		for (int j = 0; j < genotype.size(); j++) {
			if (genotype[j] != VEHICLE_DELIMITER) {
				float distanceDemand = DEMANDWEIGHT * abs(cities[genotype[j]].m_Demand - customerToCompare.m_Demand);
				float distanceTimeWindow = TIMEWINDOWWEIGHT * abs(cities[genotype[j]].m_ReadyTime - customerToCompare.m_ReadyTime);
				float distanceDistance = DISTANCEWEIGHT * distanceMatrix[customerToCompareIdx][genotype[j]].m_Distance;
				if (distanceDemand + distanceTimeWindow + distanceDistance < minDistance) {
					customerWithMinDistanceIdx = j;
					minDistance = distanceDemand + distanceTimeWindow + distanceDistance;
				}
			}
		}
        m_CustomerIndexes.push_back(genotype[customerWithMinDistanceIdx]);
		genotype.erase(genotype.begin() + customerWithMinDistanceIdx);
	}
}


optimizer\src\method\operators\selection\selections\CFitnessTournament.cpp
=============
#include "CFitnessTournament.h"
#include "../../../../utils/random/CRandom.h"

SSOIndividual *CFitnessTournament::Select(std::vector<SSOIndividual *> &population)
{
    size_t bestIdx = CRandom::GetInt(0, population.size());
    float bestFitness = population[bestIdx]->m_Fitness;

    for (size_t i = 0; i < m_TournamentSize; i++)
    {
        size_t randomIdx = CRandom::GetInt(0, population.size());
        float currentFitness = population[randomIdx]->m_Fitness;

        if (currentFitness < bestFitness)
        {
            bestFitness = currentFitness;
            bestIdx = randomIdx;
        }
    }

    return population[bestIdx];
}

optimizer\src\method\operators\selection\selections\CGapSelectionByRandomDim.cpp
=============
#include <algorithm>
#include <cfloat>
#include "CGapSelectionByRandomDim.h"
#include "../../../../utils/random/CRandom.h"

std::vector<std::pair<SMOIndividual*, SMOIndividual*>> CGapSelectionByRandomDim::Select(std::vector<SMOIndividual*>& parents, int objectiveNumber, int populationSize)
{
    // Backup in case of 1 solution in archive
    if (parents.size() < 2)
    {
        return { {parents[0], parents[0]} };
    }

    std::vector<std::pair<SMOIndividual*, SMOIndividual*>> selectedParents;
    selectedParents.reserve(populationSize);
    std::vector<float> gapValues = CalculateGapValues(parents, objectiveNumber);

    for (size_t i = 0; i < populationSize; i += 2)
    {
        size_t firstParentIdx = SelectParentIdxByTournament(parents, gapValues);
        size_t secondParentIdx = 0;
        if (m_BNTGA)
        {
            if (firstParentIdx == 0)
            {
                secondParentIdx = 1;
            }
            else if (firstParentIdx == parents.size() - 1)
            {
                secondParentIdx = parents.size() - 2;
            }
            else
            {
                secondParentIdx = firstParentIdx + (CRandom::GetInt(0, 2) == 0 ? 1 : -1);
            }
            parents[firstParentIdx]->OnSelected();
            parents[secondParentIdx]->OnSelected();
        }
        else
        {
            secondParentIdx = firstParentIdx + (CRandom::GetInt(0, 2) == 0 ? 1 : -1);
            if (secondParentIdx < 0 || secondParentIdx >= parents.size())
            {
                secondParentIdx = SelectParentIdxByTournament(parents, gapValues);
            }
        }
        selectedParents.emplace_back(parents[firstParentIdx], parents[secondParentIdx]);
    }
    return selectedParents;
}


std::vector<float> CGapSelectionByRandomDim::CalculateGapValues(std::vector<SMOIndividual*>& parents, int objectiveNumber) const
{
    size_t objectiveId = CRandom::GetInt(0, objectiveNumber);
    std::sort(parents.begin(), parents.end(), [objectiveId](const SMOIndividual* a, const SMOIndividual* b) -> bool
    {
        return a->m_NormalizedEvaluation[objectiveId] < b->m_NormalizedEvaluation[objectiveId];
    });

    // Calculate Gaps
    size_t frontSize = parents.size();
    std::vector<float> gapValues(frontSize, 0.f);

    gapValues[0] = FLT_MAX;
    gapValues[frontSize - 1] = FLT_MAX;

    for (size_t i = 1; i < frontSize - 1; ++i)
    {
        float iValue = parents[i]->m_NormalizedEvaluation[objectiveId];
        gapValues[i] = fmaxf(iValue - parents[i - 1]->m_NormalizedEvaluation[objectiveId],
                             parents[i + 1]->m_NormalizedEvaluation[objectiveId] - iValue);
    }

    if (m_BNTGA)
    {
        for (size_t i = 0; i < frontSize; ++i)
        {
            size_t selected = parents[i]->GetSelected();
            // Gap Balanced
            gapValues[i] = (gapValues[i] / (selected + 1));
            // Gap Balanced norm2 Lambda
            //gapValues[i] = (gapValues[i] / sqrtf(maxGap)) + sqrtf(log((float)globalSelections) / (selected + 1));
            // Gap Balanced norm Lambda
            //gapValues[i] = (gapValues[i] / (selected + 1)) + lambda * sqrtf(log((float)globalSelections * maxSpan) / (selected + 1));
            // Gap Balanced norm2 Lambda
            //gapValues[i] = (gapValues[i] / (selected + 1)) + lambda * sqrtf(log((float)globalSelections) * maxSpan / (selected + 1));
            // Gap Balanced Lambda 1
            //gapValues[i] = (gapValues[i] / (selected + 1)) + lambda * sqrtf(log((float)globalSelections) / (selected + 1));
        }
    }

    return gapValues;
}

size_t CGapSelectionByRandomDim::SelectParentIdxByTournament(const std::vector<SMOIndividual*>& parents, const std::vector<float>& gapValues) const
{
    size_t parentIdx = CRandom::GetInt(0, parents.size());
    float bestGap = gapValues[parentIdx];
    for (size_t i = 1; i < m_TournamentSize; ++i)
    {
        size_t randomIdx = CRandom::GetInt(0, parents.size());
        if (gapValues[randomIdx] > bestGap)
        {
            bestGap = gapValues[randomIdx];
            parentIdx = randomIdx;
        }
    }
    return parentIdx;
}

optimizer\src\method\operators\selection\selections\CRankedTournament.cpp
=============


#include "CRankedTournament.h"
#include "../../../../utils/random/CRandom.h"

SMOIndividual *CRankedTournament::Select(std::vector<SMOIndividual *> &population)
{
    size_t popSize = population.size();

    size_t bestIdx = CRandom::GetInt(0, popSize);
    size_t bestRank = population[bestIdx]->m_Rank;

    for (size_t i = 1; i < m_TournamentSize; ++i)
    {
        size_t randomIdx = CRandom::GetInt(0, popSize);
        size_t rank = population[randomIdx]->m_Rank;
        if (rank < bestRank)
        {
            bestRank = rank;
            bestIdx = randomIdx;
        }
    }

    return population[bestIdx];
}


optimizer\src\problem\problems\CVRP\CCVRP.cpp
=============
#include "CCVRP.h"

#define TTP_SAVE_FIXED_GENES 0

CCVRP::CCVRP(CCVRPTemplate &cvrpBase) : m_CVRPTemplate(cvrpBase) {
    CreateProblemEncoding();

    m_MaxObjectiveValues = {
            m_CVRPTemplate.GetMaxDistance()
    };

    m_MinObjectiveValues = {
            m_CVRPTemplate.GetMinDistance()
    };
}

SProblemEncoding &CCVRP::GetProblemEncoding() {
    return m_ProblemEncoding;
}

size_t CCVRP::GetNearestDepotIdx(const size_t cityIdx) {
    float minDist = FLT_MAX;
    size_t chosenIdx;
    auto distMtx = m_CVRPTemplate.GetDistMtx();
    auto depotIndexes = m_CVRPTemplate.GetDepots();
    auto cities = m_CVRPTemplate.GetCities();

    for (const auto idx: depotIndexes) {
        int depot_index;
        for (int i =0;i<cities.size();i++){
            if (cities[i].m_ID==idx){
                depot_index=i;
                break;
            }
        }
        if (distMtx[cityIdx][depot_index] < minDist) {
            chosenIdx = depot_index;
            minDist = distMtx[cityIdx][depot_index];
        }
    }
    return chosenIdx;
}

void CCVRP::Evaluate(AIndividual& individual) {
    // Build solution
    auto &distMtx = m_CVRPTemplate.GetDistMtx();
    int capacity = m_CVRPTemplate.GetCapacity();

    std::vector<SCityCVRP> cities = m_CVRPTemplate.GetCities();
    std::vector<size_t> depotIndexes = m_CVRPTemplate.GetDepots();

    size_t citiesSize = m_CVRPTemplate.GetCitiesSize();

    // Evaluate
    int current_load = capacity;
    float distance = 0;
    for (size_t i = 0; i < citiesSize; ++i) {
        size_t cityIdx = individual.m_Genotype.m_IntGenotype[i];
        size_t nextCityIdx = individual.m_Genotype.m_IntGenotype[(i + 1) % citiesSize];

        if (current_load < cities[nextCityIdx].m_demand) {
            const size_t depotIdx = GetNearestDepotIdx(cityIdx);

            distance += distMtx[cityIdx][depotIdx];
            distance += distMtx[depotIdx][nextCityIdx];
            current_load = capacity;
        } else {
            distance += distMtx[cityIdx][nextCityIdx];
        }

        current_load -= cities[nextCityIdx].m_demand;
    }
    
    individual.m_Evaluation = {
            distance
    };
    
    // Normalize
    for (int i = 0; i < 1; i++)
    {
        individual.m_NormalizedEvaluation[i] = (individual.m_Evaluation[i] - m_MinObjectiveValues[i]) / (m_MaxObjectiveValues[i] - m_MinObjectiveValues[i]);
    }
}

void CCVRP::CreateProblemEncoding() {
    size_t citiesSize = m_CVRPTemplate.GetCitiesSize();

    SEncodingSection citiesSection = SEncodingSection
            {
                    // city indices <0, n-1>
                    std::vector<SEncodingDescriptor>(citiesSize, SEncodingDescriptor{
                            (float) 0, (float) (citiesSize - 1)
                    }),
                    EEncodingType::PERMUTATION
            };


    m_ProblemEncoding = SProblemEncoding{1, {citiesSection}, m_CVRPTemplate.GetDistMtx()};
}

void CCVRP::LogSolution(AIndividual& individual) {

}

optimizer\src\problem\problems\CVRP\CCVRPTemplate.cpp
=============
#include "CCVRPTemplate.h"

SCityCVRP::SCityCVRP(const int& id, const float& x, const float& y, const int& demand)
{
	m_ID = id;
	m_PosX = x;
	m_PosY = y;
	m_demand=demand;
}

void CCVRPTemplate::Clear()
{
	m_Cities.clear();
	m_Capacity = 0;
	m_Trucks = 0;

	m_DistanceMatrix.clear();
	m_MinDistanceVec.clear();
}

void CCVRPTemplate::SetData(const std::vector<SCityCVRP>& cities, int capacity,int trucks,const std::vector<size_t>& depotIndexes)
{
	Clear();

	m_Cities = cities;
	m_Capacity = capacity;
	m_Trucks = trucks;
	m_DepotIndexes=depotIndexes;

	CalculateContextData();
}

float CCVRPTemplate::GetMinDistance() const {
	float dist = 0.f;
	size_t dim = m_DistanceMatrix.size();
	for (size_t i = 0; i < dim; ++i)
	{
		float minDist = FLT_MAX;
		for (size_t j = 0; j < dim; ++j)
		{
			if (i != j)
			{
				minDist = fminf(minDist, m_DistanceMatrix[i][j]);
			}
		}
		dist += minDist;
	}
	return dist;
}

float CCVRPTemplate::GetMaxDistance() const {
	return GetMinDistance() * 2.f;
}


void CCVRPTemplate::CalculateContextData()
{
	size_t dim = m_Cities.size();
	m_DistanceMatrix = std::vector<std::vector<float>>(dim, std::vector<float>(dim, 0.f));
	for (size_t i = 0; i < dim; ++i)
	{
		for (size_t j = i + 1; j < dim; ++j)
		{
			// Use ceil distance
			float dist = ceilf(sqrtf(powf(m_Cities[i].m_PosX - m_Cities[j].m_PosX, 2) + powf(m_Cities[i].m_PosY - m_Cities[j].m_PosY, 2)));
			m_DistanceMatrix[i][j] = m_DistanceMatrix[j][i] = dist;
		}
	}

	// Calculate minimum distance vector
	m_MinDistanceVec = std::vector<float>(dim, 0.f);
	for (size_t i = 0; i < dim; ++i)
	{
		float minDist = FLT_MAX;
		for (size_t j = 0; j < dim; ++j)
		{
			if (i != j)
			{
				minDist = fminf(minDist, m_DistanceMatrix[i][j]);
			}
		}
		m_MinDistanceVec[i] = minDist;
	}


}


optimizer\src\problem\problems\ECVRPTW\CECVRPTW.cpp
=============
#include "CECVRPTW.h"
#include "../../../utils/logger/CExperimentLogger.h"
#include "CECVRPTWSolution.h"
#include <iostream>
#include <sstream>

CECVRPTW::CECVRPTW(CECVRPTWTemplate& ecvrptwBase)
    : m_ECVRPTWTemplate(ecvrptwBase)
{
    CreateProblemEncoding();

    m_MaxObjectiveValues = {
        m_ECVRPTWTemplate.GetMaxDistance(),
        m_ECVRPTWTemplate.GetMaxDueTime() * (float)m_ECVRPTWTemplate.GetCustomers().size()
    };

    m_MinObjectiveValues = {
            0, //min distance
            0, //min due time
    };
}

std::vector<int> CECVRPTW::GetRealPath(AIndividual& individual)
{
    CECVRPTWSolution solution(m_ECVRPTWTemplate);
    solution.BuildSolution(individual.m_Genotype.m_IntGenotype);
    return solution.GetSolution();
}

void CECVRPTW::Evaluate(AIndividual& individual) 
{
    CECVRPTWSolution solution(m_ECVRPTWTemplate);
    solution.BuildSolution(individual.m_Genotype.m_IntGenotype);

    individual.m_Evaluation[0] = solution.GetTotalDistance();
    individual.m_Evaluation[1] = solution.GetTotalDuration();

    // Normalize
    for (int i = 0; i < 2; i++)
    {
        individual.m_NormalizedEvaluation[i] = (individual.m_Evaluation[i] - m_MinObjectiveValues[i]) / (m_MaxObjectiveValues[i] - m_MinObjectiveValues[i]);
    }
}

void CECVRPTW::CreateProblemEncoding()
{
    auto& customers = m_ECVRPTWTemplate.GetCustomers();

    SEncodingSection citiesSection = SEncodingSection
    {
        std::vector<SEncodingDescriptor>(customers.size() + m_ECVRPTWTemplate.GetVehicleCount() - 1,
            SEncodingDescriptor{
                    (float)customers[0], (float)customers[customers.size()-1]
            }
        ),
        EEncodingType::PERMUTATION
    };

    m_ProblemEncoding = SProblemEncoding{3, {citiesSection} };
}

void CECVRPTW::LogSolution(AIndividual& individual)
{
    auto realPath = GetRealPath(individual);
    std::string solution;
    for (int i = 0; i < realPath.size(); i++) {
        solution += std::to_string(realPath[i]);
        if (i != realPath.size() - 1) {
            solution += ";";
        }
    }
    CExperimentLogger::AddLine(solution.c_str());
}

void CECVRPTW::LogAdditionalData()
{
    std::ostringstream pointsData;
    auto& cityData = m_ECVRPTWTemplate.GetCities();
    for (auto& city : cityData) {
        
        pointsData << city.m_PosX << ';' << city.m_PosY << ';' << (char)city.m_Type << std::endl;
    }
    CExperimentLogger::LogResult(pointsData.str().c_str(), "points.csv");
}



optimizer\src\problem\problems\ECVRPTW\CECVRPTWSolution.cpp
=============
#include "CECVRPTWSolution.h"
#include "problem/problems/ECVRPTW/CECVRPTWTemplate.h"
#include <numeric>
#include <stdexcept>

CECVRPTWSolution::CECVRPTWSolution(CECVRPTWTemplate& problemTemplate)
    : m_ECVRPTWTemplate(problemTemplate)
{
}

float CECVRPTWSolution::GetTotalDistance() const
{
    return std::accumulate(m_Distance.begin(), m_Distance.end(), 0.f);
}

float CECVRPTWSolution::GetTotalDuration() const
{
    return std::accumulate(m_CurrentTime.begin(), m_CurrentTime.end(), 0.f);
}

void CECVRPTWSolution::BuildSolution(const std::vector<int>& initialAssignment)
{
    PrepareData(initialAssignment);

    auto& distMtx = m_ECVRPTWTemplate.GetDistInfoMtx();
    auto& cities = m_ECVRPTWTemplate.GetCities();

    int currentCar = 0;
    for (m_CurrentSolutionIdx = 0; m_CurrentSolutionIdx < m_Solution.size(); ++m_CurrentSolutionIdx)
    {
        size_t nextCityIdx = m_Solution[(m_CurrentSolutionIdx + 1) % m_Solution.size()];
        if (nextCityIdx == VEHICLE_DELIMITER)
        {
            currentCar++;
            continue;
        }

        if (CanSatisfyDemand(currentCar, nextCityIdx))
        {
            if (CanSafelyReach(currentCar, nextCityIdx))
            {
                MoveCarToNextCity(currentCar, nextCityIdx);
            }
            else
            {
                // We assume, we can safely reach the recharge station, as we always check beforehand
                MoveCarToRechargeStationTowardsCity(currentCar, nextCityIdx);
            }
        }
        else
        {
            size_t depotIdx = m_ECVRPTWTemplate.GetNearestDepotIdx(m_CurrentPosition[currentCar]);
            if (CanSafelyReach(currentCar, depotIdx))
            {
                // We assume, that we can safely reach any city (including recharge station) from the depot
                MoveCarToDepoLoadAndRecharge(currentCar, depotIdx);
            }
            else
            {
                // There is a chance, we will not reach the depot at the moment but must reach recharge station
                MoveCarToRechargeStationTowardsCity(currentCar, depotIdx);
            }
        }
    }
}

bool CECVRPTWSolution::CanSatisfyDemand(size_t carIdx, size_t cityIdx) const
{
    return m_CurrentLoad[carIdx] >= m_ECVRPTWTemplate.GetCities()[cityIdx].m_Demand;
}

bool CECVRPTWSolution::CanSafelyReach(size_t carIdx, size_t cityIdx) const
{
    float fuelToTarget = m_ECVRPTWTemplate.GetRequiredFuel(m_CurrentPosition[carIdx], cityIdx);
    size_t nearestChargingToCityIdx = m_ECVRPTWTemplate.GetNearestChargingStationIdx(cityIdx);
    float fuelFromTargetToNearestCharging = m_ECVRPTWTemplate.GetRequiredFuel(cityIdx, nearestChargingToCityIdx);
    return m_CurrentTankCapacity[carIdx] >= (fuelToTarget + fuelFromTargetToNearestCharging);
}

void CECVRPTWSolution::PrepareData(const std::vector<int>& initialAssignment)
{
    size_t vehicleCount = m_ECVRPTWTemplate.GetVehicleCount();
    m_CurrentLoad = std::vector<int>(vehicleCount, m_ECVRPTWTemplate.GetCapacity());
    m_CurrentPosition = std::vector<size_t>(vehicleCount, DEPOT_CITY_ID);
    m_Distance = std::vector<float>(vehicleCount, 0.f);
    m_CurrentTankCapacity = std::vector<float>(vehicleCount, m_ECVRPTWTemplate.GetTankCapcity());
    m_CurrentTime = std::vector<float>(vehicleCount, 0.f);

    m_Solution = initialAssignment;
    m_Solution.emplace(m_Solution.begin(), DEPOT_CITY_ID);
    m_Solution.emplace(m_Solution.end(), DEPOT_CITY_ID);
    for (size_t i = 0; i < m_Solution.size(); ++i)
    {
        if (m_Solution[i] == VEHICLE_DELIMITER)
        {
            m_Solution.emplace(m_Solution.begin() + i, DEPOT_CITY_ID);
            m_Solution.emplace(m_Solution.begin() + i + 2, DEPOT_CITY_ID);
            i += 2;
        }
    }
}

float CECVRPTWSolution::CalculateRefuelTime(float tankCapacity, float currentTankCapacity)
{
    return (tankCapacity - currentTankCapacity) / m_ECVRPTWTemplate.GetRefuelingRate();
}

void CECVRPTWSolution::MoveCarToDepoLoadAndRecharge(size_t carIdx, size_t depotIdx)
{
    auto& distMtx = m_ECVRPTWTemplate.GetDistInfoMtx();
    size_t& currentCityIdx = m_CurrentPosition[carIdx];

    //To depot
    m_Distance[carIdx] += distMtx[currentCityIdx][depotIdx].m_Distance;
    m_CurrentTime[carIdx] += distMtx[currentCityIdx][depotIdx].m_TravelTime;
    m_CurrentTankCapacity[carIdx] -= distMtx[currentCityIdx][depotIdx].m_FuelConsumption;

    //Depot refuel
    m_CurrentTime[carIdx] += CalculateRefuelTime(m_ECVRPTWTemplate.GetTankCapcity(), m_CurrentTankCapacity[carIdx]);
    m_CurrentTankCapacity[carIdx] = m_ECVRPTWTemplate.GetTankCapcity();

    //Depot car loading
    m_CurrentLoad[carIdx] = m_ECVRPTWTemplate.GetCapacity();

    //Add depot visit to solution
    m_Solution.emplace(m_Solution.begin() + (int)m_CurrentSolutionIdx + 1, depotIdx);
    currentCityIdx = depotIdx;
}

void CECVRPTWSolution::MoveCarToDepoLoadRechargeAndThenToCity(size_t carIdx, size_t depotIdx, size_t nextCityIdx)
{
    auto& distMtx = m_ECVRPTWTemplate.GetDistInfoMtx();
    auto& cities = m_ECVRPTWTemplate.GetCities();

    size_t& currentCityIdx = m_CurrentPosition[carIdx];

    //To depot
    m_Distance[carIdx] += distMtx[currentCityIdx][depotIdx].m_Distance;
    m_CurrentTime[carIdx] += distMtx[currentCityIdx][depotIdx].m_TravelTime;
    m_CurrentTankCapacity[carIdx] -= distMtx[currentCityIdx][depotIdx].m_FuelConsumption;

    //Depot refuel
    m_CurrentTime[carIdx] += CalculateRefuelTime(m_ECVRPTWTemplate.GetTankCapcity(), m_CurrentTankCapacity[carIdx]);
    m_CurrentTankCapacity[carIdx] = m_ECVRPTWTemplate.GetTankCapcity();

    //Depot car loading
    m_CurrentLoad[carIdx] = m_ECVRPTWTemplate.GetCapacity();

    //To next city
    m_Distance[carIdx] += distMtx[depotIdx][nextCityIdx].m_Distance;
    m_CurrentTime[carIdx] += distMtx[depotIdx][nextCityIdx].m_TravelTime;
    m_CurrentTankCapacity[carIdx] -= distMtx[depotIdx][nextCityIdx].m_FuelConsumption;

    m_CurrentLoad[carIdx] -= cities[nextCityIdx].m_Demand;

    //Add depot visit to solution
    m_Solution.emplace(m_Solution.begin() + (int)m_CurrentSolutionIdx + 1, depotIdx);

    HandleTimeOnCity(carIdx, nextCityIdx);
    m_CurrentSolutionIdx++;
    currentCityIdx = nextCityIdx;
}

void CECVRPTWSolution::MoveCarToNextCity(size_t carIdx, size_t nextCityIdx)
{
    auto& distMtx = m_ECVRPTWTemplate.GetDistInfoMtx();
    auto& cities = m_ECVRPTWTemplate.GetCities();

    size_t& currentCityIdx = m_CurrentPosition[carIdx];
    m_Distance[carIdx] += distMtx[currentCityIdx][nextCityIdx].m_Distance;
    m_CurrentTime[carIdx] += distMtx[currentCityIdx][nextCityIdx].m_TravelTime;
    m_CurrentTankCapacity[carIdx] -= distMtx[currentCityIdx][nextCityIdx].m_FuelConsumption;
    m_CurrentLoad[carIdx] -= cities[nextCityIdx].m_Demand;

    HandleTimeOnCity(carIdx, nextCityIdx);

    m_CurrentTime[carIdx] += cities[nextCityIdx].m_ServiceTime;
    currentCityIdx = nextCityIdx;
}

void CECVRPTWSolution::HandleTimeOnCity(size_t carIdx, size_t nextCityIdx)
{
    auto& cities = m_ECVRPTWTemplate.GetCities();
    auto dayLength = m_ECVRPTWTemplate.GetMaxDueTime();

    if (std::fmod(m_CurrentTime[carIdx], dayLength) < cities[nextCityIdx].m_ReadyTime)
    {
        m_CurrentTime[carIdx] += cities[nextCityIdx].m_ReadyTime - std::fmod(m_CurrentTime[carIdx], dayLength);
    }
    else if (std::fmod(m_CurrentTime[carIdx], dayLength) > cities[nextCityIdx].m_DueTime)
    {
        float timeToEndOfDay = dayLength - std::fmod(m_CurrentTime[carIdx], dayLength);
        m_CurrentTime[carIdx] += timeToEndOfDay;
        m_CurrentTime[carIdx] += cities[nextCityIdx].m_ReadyTime;
    }
}

void CECVRPTWSolution::MoveCarToNearestRechargeStation(size_t carIdx)
{
    size_t nearestChargingStationIdx = m_ECVRPTWTemplate.GetNearestChargingStationIdx(m_CurrentPosition[carIdx]);
    MoveCarToRechargeStation(carIdx, nearestChargingStationIdx);
}

void CECVRPTWSolution::MoveCarToRechargeStationTowardsCity(size_t carIdx, size_t nextCityIdx)
{
    auto& chargingStations = m_ECVRPTWTemplate.GetChargingStations();
    auto& distMtx = m_ECVRPTWTemplate.GetDistInfoMtx();
    size_t currentCityIdx = m_CurrentPosition[carIdx];

    // this is simple approach but works as expected - get nearest to target, reachable station
    float bestDist = FLT_MAX;
    size_t bestStationIdx = distMtx.size();
    float currentFuel = m_CurrentTankCapacity[carIdx];
    for (size_t stationIdx : chargingStations)
    {
        float d = distMtx[stationIdx][nextCityIdx].m_Distance;
        float f = distMtx[currentCityIdx][stationIdx].m_FuelConsumption;
        if (d < bestDist && f <= currentFuel)
        {
            bestDist = d;
            bestStationIdx = stationIdx;
        }
    }

    if (bestStationIdx >= distMtx.size())
    {
        throw std::runtime_error("Cannot find reachable station!");
    }

    MoveCarToRechargeStation(carIdx, bestStationIdx);
}

void CECVRPTWSolution::MoveCarToRechargeStation(size_t carIdx, size_t stationIdx)
{
    auto& distMtx = m_ECVRPTWTemplate.GetDistInfoMtx();

    size_t& currentCityIdx = m_CurrentPosition[carIdx];
    m_Distance[carIdx] += distMtx[currentCityIdx][stationIdx].m_Distance;
    m_CurrentTime[carIdx] += distMtx[currentCityIdx][stationIdx].m_TravelTime;
    m_CurrentTime[carIdx] += CalculateRefuelTime(m_ECVRPTWTemplate.GetTankCapcity(), m_CurrentTankCapacity[carIdx]);
    m_CurrentTankCapacity[carIdx] = m_ECVRPTWTemplate.GetTankCapcity();
    m_Solution.emplace(m_Solution.begin() + (int)m_CurrentSolutionIdx + 1, stationIdx);
    currentCityIdx = stationIdx;
    if (currentCityIdx == DEPOT_CITY_ID) // TODO - handle to not use index
    {
        m_CurrentLoad[carIdx] = m_ECVRPTWTemplate.GetCapacity();
    }
}

optimizer\src\problem\problems\ECVRPTW\CECVRPTWTemplate.cpp
=============
#include <iostream>
#include "CECVRPTWTemplate.h"

SCityECVRPTW::SCityECVRPTW(const int& id
	, const std::string& strId
	, const ENodeType type
	, const float& x
	, const float& y
	, const int& demand
	, const float& readyTime
	, const float& dueTime
	, const float& serviceTime
) : m_StrID(strId)
{
	m_ID = id;
	m_Type = type;
	m_PosX = x;
	m_PosY = y;
	m_Demand = demand;
	m_ReadyTime = readyTime;
	m_DueTime = dueTime;
	m_ServiceTime = serviceTime;
}

void CECVRPTWTemplate::Clear()
{
	m_Capacity = 0;
	m_AverageVelocity = 0;
	m_FuelConsumptionRate = 0;
	m_RefuelingRate = 0;
	m_TankCapacity = 0;

    m_Cities.clear();
    m_ChargingStationIndexes.clear();
    m_DepotIndexes.clear();
    m_CustomerIndexes.clear();
	m_DistanceInfoMatrix.clear();
	m_MinDistanceVec.clear();
}

void CECVRPTWTemplate::SetData(std::vector<SCityECVRPTW>& cities
	, int capacity
	, float tankCapacity
	, float fuelConsumptionRate
	, float refuelingRate
	, float averageVelocity
	, std::vector<size_t>& chargingStationIndexes
	, std::vector<size_t>& depotIndexes
	, std::vector<size_t>& customerIndexes
	, int vehicleCount
)
{
	Clear();

	m_Cities = cities;
	m_Capacity = capacity;
	m_DepotIndexes = depotIndexes;
	m_ChargingStationIndexes = chargingStationIndexes;
    m_CustomerIndexes = customerIndexes;
	m_TankCapacity = tankCapacity;
	m_FuelConsumptionRate = fuelConsumptionRate;
	m_RefuelingRate = refuelingRate;
	m_AverageVelocity = averageVelocity;
	m_VehicleCount = vehicleCount;

	CalculateContextData();
}

float CECVRPTWTemplate::GetMinDistance() const {
	float dist = 0.f;
	size_t dim = m_DistanceInfoMatrix.size();
	for (size_t i = 0; i < dim; ++i)
	{
		float minDist = FLT_MAX;
		for (size_t j = 0; j < dim; ++j)
		{
			if (i != j)
			{
				minDist = fminf(minDist, m_DistanceInfoMatrix[i][j].m_Distance);
			}
		}
		dist += minDist;
	}
	return dist;
}

float CECVRPTWTemplate::GetMaxDistance() const {
	float dist = 0.f;
	size_t dim = m_DistanceInfoMatrix.size();
	for (size_t i = 0; i < dim; ++i)
	{
		float maxDist = FLT_MIN;
		for (size_t j = 0; j < dim; ++j)
		{
			if (i != j)
			{
				maxDist = fmaxf(maxDist, m_DistanceInfoMatrix[i][j].m_Distance);
			}
		}
		dist += maxDist;
	}
	return dist;
}

float CECVRPTWTemplate::GetMaxTimeService() const {
	float maxTime = FLT_MIN;
	size_t dim = m_Cities.size();
	for (size_t i = 0; i < dim; ++i)
	{
		if (maxTime < m_Cities[i].m_ServiceTime) {
			maxTime = m_Cities[i].m_ServiceTime;
		}
	}
	return maxTime;
}

float CECVRPTWTemplate::GetRequiredFuel(size_t cityIdx, size_t nextCityIdx) const
{
    return m_DistanceInfoMatrix[cityIdx][nextCityIdx].m_FuelConsumption;
}

size_t CECVRPTWTemplate::GetNearestDepotIdx(size_t cityIdx) const
{
    // TODO - cache

    float minDist = FLT_MAX;
    size_t chosenIdx;
    auto& distMtx = GetDistInfoMtx();
    auto& depotIndexes = GetDepots();
    auto& cities = GetCities();

    for (const auto idx : depotIndexes)
    {
        int depotIndex;
        for (int i = 0; i < cities.size(); i++)
        {
            if (cities[i].m_ID == idx)
            {
                depotIndex = i;
                break;
            }
        }
        if (distMtx[cityIdx][depotIndex].m_Distance < minDist)
        {
            chosenIdx = depotIndex;
            minDist = distMtx[cityIdx][depotIndex].m_Distance;
        }
    }
    return chosenIdx;
}

size_t CECVRPTWTemplate::GetNearestChargingStationIdx(size_t cityIdx) const
{
    // TODO - cache
    
    float minDist = FLT_MAX;
    size_t chosenIdx;
    auto& distMtx = GetDistInfoMtx();
    auto& depotIndexes = GetChargingStations();
    auto& cities = GetCities();

    for (const auto idx : depotIndexes)
    {
        int depotIndex;
        for (int i = 0; i < cities.size(); i++)
        {
            if (cities[i].m_ID == idx)
            {
                depotIndex = i;
                break;
            }
        }
        if (distMtx[cityIdx][depotIndex].m_Distance < minDist)
        {
            chosenIdx = depotIndex;
            minDist = distMtx[cityIdx][depotIndex].m_Distance;
        }
    }
    return chosenIdx;
}

bool CECVRPTWTemplate::Validate() const
{
    bool isValid = true;
    for (size_t i = 0; i < m_DistanceInfoMatrix.size(); ++i)
    {
        if (m_Cities[i].m_Type == ENodeType::ChargingStation)
        {
            size_t depotIdx = GetNearestDepotIdx(i);
            // depot can be reached from any charging station
            if (m_DistanceInfoMatrix[i][depotIdx].m_FuelConsumption > m_TankCapacity)
            {
                std::cout << "Depot cannot be reached from the charging station [" << i << "]!" << std::endl;
                isValid = false;
            }
        }
        size_t chargingStationIdx = GetNearestChargingStationIdx(i);
        // any city can be reached from the charging station and back
        if ((m_DistanceInfoMatrix[chargingStationIdx][i].m_FuelConsumption + m_DistanceInfoMatrix[i][chargingStationIdx].m_FuelConsumption) > m_TankCapacity)
        {
            std::cout << "City [" << i << "] cannot be safely reached from the nearest charging station!" << std::endl;
            isValid = false;
        }
    }
    return isValid;
}

void CECVRPTWTemplate::CalculateContextData()
{
	size_t dim = m_Cities.size();
	m_DistanceInfoMatrix = std::vector<std::vector<SDistanceInfo>>(dim, std::vector<SDistanceInfo>(dim, SDistanceInfo{0, 0, 0}));
	for (size_t i = 0; i < dim; ++i)
	{
		for (size_t j = 0; j < dim; ++j)
		{
			float dist = sqrtf(powf(m_Cities[i].m_PosX - m_Cities[j].m_PosX, 2) + powf(m_Cities[i].m_PosY - m_Cities[j].m_PosY, 2));
			float time = dist / m_AverageVelocity;
			float fuelConsumptionRate = dist * m_FuelConsumptionRate;
			m_DistanceInfoMatrix[i][j] = SDistanceInfo
			{
				dist,
				time,
				fuelConsumptionRate
			};
		}
	}

	// Calculate minimum distance vector
	m_MinDistanceVec = std::vector<float>(dim, 0.f);
	for (size_t i = 0; i < dim; ++i)
	{
		float minDist = FLT_MAX;
		for (size_t j = 0; j < dim; ++j)
		{
			if (i != j)
			{
				minDist = fminf(minDist, m_DistanceInfoMatrix[i][j].m_Distance);
			}
		}
		m_MinDistanceVec[i] = minDist;
	}
}


optimizer\src\problem\problems\MSRCPSP\CMSRCPSP_TA.cpp
=============
#include "CMSRCPSP_TA.h"
#include "../../../utils/logger/CExperimentLogger.h"

CMSRCPSP_TA::CMSRCPSP_TA(CScheduler& scheduler, size_t objCount)
    : m_Scheduler(scheduler)
    , m_ObjCount(objCount)
{
    CreateProblemEncoding();

    m_MaxObjectiveValues = {
            m_Scheduler.GetMaxDuration(),
            m_Scheduler.GetMaxCost(),
            m_Scheduler.GetMaxAvgCashFlowDev(),
            m_Scheduler.GetMaxSkillOveruse(),
            m_Scheduler.GetMaxAvgUseOfResTime()
    };

    m_MinObjectiveValues = {
            m_Scheduler.GetMinDuration(),
            m_Scheduler.GetMinCost(),
            m_Scheduler.GetMinAvgCashFlowDev(),
            m_Scheduler.GetMinSkillOveruse(),
            m_Scheduler.GetMinAvgUseOfResTime()
    };
}

SProblemEncoding &CMSRCPSP_TA::GetProblemEncoding()
{
    return m_ProblemEncoding;
}

void CMSRCPSP_TA::Evaluate(AIndividual& individual)
{
    m_Scheduler.Reset();
    for (size_t i = 0; i < individual.m_Genotype.m_FloatGenotype.size(); ++i)
    {
        TResourceID selectedResourceId = m_CapableResources[i][(size_t)individual.m_Genotype.m_FloatGenotype[i]];
        m_Scheduler.Assign(i, selectedResourceId);
    }

    m_Scheduler.BuildTimestamps_TA();

    individual.m_Evaluation =
            {
                    m_Scheduler.EvaluateDuration(),
                    m_Scheduler.EvaluateCost(),
                    m_Scheduler.EvaluateAvgCashFlowDev(),
                    m_Scheduler.EvaluateSkillOveruse(),
                    m_Scheduler.EvaluateAvgUseOfResTime()
            };

    // Normalize
    for (int i = 0; i < m_ObjCount; i++)
    {
        individual.m_NormalizedEvaluation[i] = (individual.m_Evaluation[i] - m_MinObjectiveValues[i]) / (m_MaxObjectiveValues[i] - m_MinObjectiveValues[i]);
    }
}

void CMSRCPSP_TA::LogSolution(AIndividual& individual)
{
    Evaluate(individual);
    CExperimentLogger::WriteSchedulerToFile(m_Scheduler, individual);
}

float CMSRCPSP_TA::FindBestGeneValueCostWise(size_t geneIdx) const
{
    float bestGeneValue = 0.f;
    float cheapestValue = FLT_MAX;
    const std::vector<TResourceID>& resourceIds = m_CapableResources[geneIdx];
    for (size_t i = 0; i < resourceIds.size(); ++i)
    {
        float salary = m_Scheduler.GetResourceById(resourceIds[i])->GetSalary();
        if (salary < cheapestValue)
        {
            cheapestValue = salary;
            bestGeneValue = (float)i;
        }
    }
    return bestGeneValue;
}

std::vector<size_t> CMSRCPSP_TA::FindNumberOfResourcesUse(const std::vector<float>& solution) const
{
    const std::vector<CResource>& resources = m_Scheduler.GetResources();
    std::vector<size_t> resourcesUsage(resources.size(), 0);

    for (size_t i = 0; i < solution.size(); ++i)
    {
        TResourceID selectedResourceId = m_CapableResources[i][(size_t)solution[i]];
        resourcesUsage[selectedResourceId - 1] += 1;
    }

    return resourcesUsage;
}

float CMSRCPSP_TA::FindBestGeneValueUsageWise(size_t geneIdx, const std::vector<size_t>& currentResourcesUsage) const
{
    float bestGeneValue = 0.f;
    size_t smallestUsage = SIZE_MAX;
    const std::vector<TResourceID>& resourceIds = m_CapableResources[geneIdx];
    for (size_t i = 0; i < resourceIds.size(); ++i)
    {
        size_t usage = currentResourcesUsage[resourceIds[i] - 1];
        if (usage < smallestUsage)
        {
            smallestUsage = usage;
            bestGeneValue = (float)i;
        }
    }
    return bestGeneValue;
}

void CMSRCPSP_TA::CreateProblemEncoding()
{
    m_CapableResources.clear();
    m_UpperBounds.clear();

    const std::vector<CTask>& tasks = m_Scheduler.GetTasks();
    m_CapableResources.reserve(tasks.size());
    m_UpperBounds.reserve(tasks.size());

    for (const CTask& task: tasks)
    {
        std::vector<TResourceID> capableResourceIds;
        m_Scheduler.GetCapableResources(task, capableResourceIds);
        m_CapableResources.push_back(capableResourceIds);
        m_UpperBounds.push_back(capableResourceIds.size());
    }

    SEncodingSection associationSection;
    associationSection.m_SectionType = EEncodingType::ASSOCIATION;
    for (const size_t& ub: m_UpperBounds)
    {
        associationSection.m_SectionDescription.push_back({(float) 0, (float) ub});
    }
    m_ProblemEncoding = SProblemEncoding{(int)m_ObjCount, {associationSection}};
}


optimizer\src\problem\problems\MSRCPSP\CMSRCPSP_TO.cpp
=============
#include "CMSRCPSP_TO.h"
#include "../../../utils/logger/CExperimentLogger.h"

CMSRCPSP_TO::CMSRCPSP_TO(CScheduler& scheduler, size_t objCount)
        : m_Scheduler(scheduler)
        , m_ObjCount(objCount)
{
    CreateProblemEncoding();
    m_Scheduler.SetCapableResources(m_CapableResources);

    m_MaxObjectiveValues = {
            m_Scheduler.GetMaxDuration(),
            m_Scheduler.GetMaxCost(),
            m_Scheduler.GetMaxAvgCashFlowDev(),
            m_Scheduler.GetMaxSkillOveruse(),
            m_Scheduler.GetMaxAvgUseOfResTime()
    };

    m_MinObjectiveValues = {
            m_Scheduler.GetMinDuration(),
            m_Scheduler.GetMinCost(),
            m_Scheduler.GetMinAvgCashFlowDev(),
            m_Scheduler.GetMinSkillOveruse(),
            m_Scheduler.GetMinAvgUseOfResTime()
    };
}

SProblemEncoding& CMSRCPSP_TO::GetProblemEncoding()
{
    return m_ProblemEncoding;
}

void CMSRCPSP_TO::Evaluate(AIndividual& individual)
{
    m_Scheduler.Reset();
    m_Scheduler.BuildTimestamps_TO(individual.m_Genotype.m_IntGenotype);

    // We assume this is 5 dim problem
    individual.m_Evaluation =
    {
            m_Scheduler.EvaluateDuration(),
            m_Scheduler.EvaluateCost(),
            m_Scheduler.EvaluateAvgCashFlowDev(),
            m_Scheduler.EvaluateSkillOveruse(),
            m_Scheduler.EvaluateAvgUseOfResTime()
    };

    // Normalize
    for (int i = 0; i < m_ObjCount; i++)
    {
        individual.m_NormalizedEvaluation[i] = (individual.m_Evaluation[i] - m_MinObjectiveValues[i]) / (m_MaxObjectiveValues[i] - m_MinObjectiveValues[i]);
    }
}

void CMSRCPSP_TO::LogSolution(AIndividual& individual)
{
    Evaluate(individual);
    CExperimentLogger::WriteSchedulerToFile(m_Scheduler, individual);
}

void CMSRCPSP_TO::CreateProblemEncoding()
{
    m_CapableResources.clear();

    const std::vector<CTask>& tasks = m_Scheduler.GetTasks();
    m_CapableResources.reserve(tasks.size());

    for (const CTask& task : tasks)
    {
        std::vector<TResourceID> capableResourceIds;
        m_Scheduler.GetCapableResources(task, capableResourceIds);
        m_CapableResources.push_back(capableResourceIds);
    }

    size_t tasksSize = tasks.size();
    SEncodingSection permutationSection = SEncodingSection
    {
        std::vector<SEncodingDescriptor>(tasksSize, SEncodingDescriptor{
                (float)0, (float)(tasksSize - 1)
        }),
        EEncodingType::PERMUTATION
    };
    
    m_ProblemEncoding = SProblemEncoding{ (int)m_ObjCount, {permutationSection} };
}


optimizer\src\problem\problems\MSRCPSP\CResource.cpp
=============
#include "CResource.h"

CResource::CResource(TResourceID id, float salary, const std::vector<SSkill> &skills)
        : m_ID(id), m_Salary(salary), m_Skills(skills), m_Finish(-1), m_WorkingTime(-1)
{
}

bool CResource::HasSkill(const SSkill &querySkill) const
{
    for (const SSkill &availableSkill: m_Skills)
    {
        if (availableSkill.m_TypeID == querySkill.m_TypeID)
        {
            // We assume that resource can have only one entry per skill type
            return availableSkill.m_Level >= querySkill.m_Level;
        }
    }

    return false;
}

bool CResource::GetSkillLevel(TSkillType skillType, TSkillLevel &skillLevel) const
{
    for (const SSkill &availableSkill: m_Skills)
    {
        if (availableSkill.m_TypeID == skillType)
        {
            // We assume that resource can have only one entry per skill type
            skillLevel = availableSkill.m_Level;
            return true;
        }
    }

    return false;
}


optimizer\src\problem\problems\MSRCPSP\CScheduler.cpp
=============
#include "CScheduler.h"
#include <numeric>
#include <algorithm>
#include <limits>
#include <stack>

void CScheduler::SetCapableResources(const std::vector<std::vector<TResourceID>>& capableResources)
{
    m_CapableResources = capableResources;
}

void CScheduler::SetTasks(const std::vector<CTask> &tasks)
{
    m_Tasks = tasks;
}

void CScheduler::SetResources(const std::vector<CResource> &resources)
{
    m_Resources = resources;
}

const CTask* CScheduler::GetTaskById(TTaskID taskId) const
{
    return taskId <= m_Tasks.size() ? &m_Tasks[taskId - 1] : nullptr;
}

const CResource* CScheduler::GetResourceById(TResourceID resourceId) const
{
    return resourceId <= m_Resources.size() ? &m_Resources[resourceId - 1] : nullptr;
}

void CScheduler::Assign(size_t taskIndex, TResourceID resourceId)
{
    m_Tasks[taskIndex].SetResourceID(resourceId);
}

void CScheduler::BuildTimestamps_TA()
{
    for (CResource &resource: m_Resources)
    {
        resource.SetFinish(0);
        resource.SetWorkingTime(0);
    }

    // Reset tasks start
    for (size_t i = 0; i < m_Tasks.size(); ++i)
    {
        m_Tasks[i].SetStart(-1);
    }

    // Assign tasks with relation requirements
    for (size_t i = 0; i < m_Tasks.size(); ++i)
    {
        if (m_Tasks[i].GetHasSuccessors())
        {
            BuildTimestampForTask_TA(m_Tasks[i]);
        }
    }

    // Assign rest of the tasks
    for (size_t i = 0; i < m_Tasks.size(); ++i)
    {
        if (!m_Tasks[i].GetHasSuccessors())
        {
            BuildTimestampForTask_TA(m_Tasks[i]);
        }
    }
}

void CScheduler::BuildTimestamps_TO(std::vector<int>& tasksIndexes)
{
    for (CResource& resource : m_Resources)
    {
        resource.SetFinish(0);
        resource.SetWorkingTime(0);
    }

    for (size_t i = 0; i < m_Tasks.size(); ++i)
    {
        m_Tasks[i].SetStart(-1);
    }

    for (size_t i = 0; i < tasksIndexes.size(); ++i)
    {
        AssignTask(tasksIndexes[i]);
    }
}

void CScheduler::AssignTask(size_t taskIndex)
{
    if (m_Tasks[taskIndex].GetStart() == -1)
    {
        for (TTaskID predecessorId: m_Tasks[taskIndex].GetPredecessors())
        {
            if (m_Tasks[predecessorId - 1].GetResourceID() == -1)
            {
                AssignTask(predecessorId - 1);
            }
        }

        BuildTimestampForTask_TO(taskIndex);
    }
}

void CScheduler::BuildTimestampForTask_TA(CTask &task)
{
    CResource &resource = m_Resources[(size_t) task.GetResourceID() - 1];
    TTime start = std::max(GetEarliestTime(task), resource.GetFinish());
    task.SetStart(start);
    resource.SetFinish(start + task.GetDuration());
    resource.AddWorkingTime(task.GetDuration());
}

void CScheduler::BuildTimestampForTask_TO(size_t taskIndex)
{
    CTask& task = m_Tasks[taskIndex];
    TTime earliestTime = GetEarliestTime(task);

    TResourceID bestCapableResourceId = GetBestCapableResourceId(taskIndex, earliestTime);
    Assign(taskIndex, bestCapableResourceId);

    CResource& resource = m_Resources[task.GetResourceID() - 1];
    TTime start = std::max(earliestTime, resource.GetFinish());
    task.SetStart(start);
    resource.SetFinish(start + task.GetDuration());
    resource.AddWorkingTime(task.GetDuration());
}

TResourceID CScheduler::GetBestCapableResourceId(size_t taskIndex, TTime earliestTime)
{
    CTask& task = m_Tasks[taskIndex];

    TResourceID bestCapableResourceId = m_CapableResources[taskIndex][0];
    TTime earliestBestCapableResourceTime = std::numeric_limits<short>::max();

    for (int i = 0; i < m_CapableResources[taskIndex].size(); ++i)
    {
        CResource& resource = m_Resources[m_CapableResources[taskIndex][i] - 1];
        TTime startTime = std::max(resource.GetFinish(), earliestTime);

        if (startTime < earliestBestCapableResourceTime)
        {
            earliestBestCapableResourceTime = startTime;
            bestCapableResourceId = m_CapableResources[taskIndex][i];
        }
    }

    return bestCapableResourceId;
}

std::vector<size_t> CScheduler::GetTasksIndexes(std::vector<float>& priorities)
{
    std::vector<size_t> tasksIndexes(priorities.size());
    std::iota(tasksIndexes.begin(), tasksIndexes.end(), 0);

    std::stable_sort(tasksIndexes.begin(), tasksIndexes.end(),
        [&priorities](size_t i1, size_t i2) {return priorities[i1] > priorities[i2]; });

    return tasksIndexes;
}

void CScheduler::Clear()
{
    m_Tasks.clear();
    m_Resources.clear();
}

void CScheduler::Reset()
{
    for (CTask &task: m_Tasks)
    {
        task.SetStart(-1);
        task.SetResourceID(-1);
    }

    for (CResource &resource: m_Resources)
    {
        resource.SetFinish(-1);
    }
}

float CScheduler::EvaluateDuration()
{
    TTime duration = 0;
    for (const CResource &resource: m_Resources)
    {
        if (resource.GetFinish() > duration)
        {
            duration = resource.GetFinish();
        }
    }
    return duration;
}

float CScheduler::EvaluateCost()
{
    float cost = 0.f;
    for (const CTask &task: m_Tasks)
    {
        TResourceID resourceId = task.GetResourceID();
        if (resourceId > 0)
        {
            CResource &resource = m_Resources[(size_t) task.GetResourceID() - 1];
            cost += resource.GetSalary() * task.GetDuration();
        }
    }
    return cost;
}

float CScheduler::EvaluateAvgCashFlowDev()
{
    // Calculate total duration
    TTime duration = 0;
    for (const CResource &resource: m_Resources)
    {
        if (resource.GetFinish() > duration)
        {
            duration = resource.GetFinish();
        }
    }

    // Init time stamps with 0
    std::vector<float> cashFlows((size_t) duration, 0.f);
    float totalCashFlow = 0.f;
    for (const CTask &task: m_Tasks)
    {
        if (task.GetStart() >= 0)
        {
            TResourceID resourceId = task.GetResourceID();
            if (resourceId > 0)
            {
                CResource &resource = m_Resources[(size_t) task.GetResourceID() - 1];
                float resourceSalary = resource.GetSalary();
                for (TTime i = task.GetStart(); i < task.GetExpectedFinish(); ++i)
                {
                    cashFlows[i] += resourceSalary;
                    totalCashFlow += resourceSalary;
                }
            }
        }
    }

    float avgCashFlow = totalCashFlow / (float) duration;

    // Calculate deviation
    float totalCashFlowDeviation = 0.f;
    for (const float &cashFlow: cashFlows)
    {
        totalCashFlowDeviation += fabsf(cashFlow - avgCashFlow);
    }
    return totalCashFlowDeviation;
}

float CScheduler::EvaluateSkillOveruse()
{
    // In my opinion - it could be calculated differently
    // Now, it does not include resource's additional skills which are not required by a task
    float overuse = 0.f;
    for (const CTask &task: m_Tasks)
    {
        TResourceID resourceId = task.GetResourceID();
        if (resourceId > 0)
        {
            CResource &resource = m_Resources[(size_t) task.GetResourceID() - 1];
            for (const SSkill &reqSkill: task.GetRequiredSkills())
            {
                TSkillLevel resSkillLevel = 0;
                if (resource.GetSkillLevel(reqSkill.m_TypeID, resSkillLevel))
                {
                    overuse += (resSkillLevel - reqSkill.m_Level);
                }
            }
        }
    }
    return overuse;
}

float CScheduler::EvaluateAvgUseOfResTime()
{
    // It's more of a deviation from expected work time
    static const float s_ExpectedUsedTime = (float) GetMaxDuration() / (float) m_Resources.size();
    float workingTimeSum = 0.f;
    for (const CResource &res: m_Resources)
    {
        workingTimeSum += fabsf(res.GetWorkingTime() - s_ExpectedUsedTime);
    }
    return workingTimeSum;
}

void CScheduler::GetCapableResources(const CTask &task, std::vector<TResourceID> &resourceIds) const
{
    resourceIds.clear();
    for (const CResource &resource: m_Resources)
    {
        if (task.CanBeExecutedBy(resource))
        {
            resourceIds.push_back(resource.GetResourceID());
        }
    }
}

TTime CScheduler::GetEarliestTime(const CTask &task) const
{
    TTime earliestTime = 0;

    for (TTaskID predId: task.GetPredecessors())
    {
        TTime expectedFinish = m_Tasks[(size_t) predId - 1].GetExpectedFinish();
        if (expectedFinish > earliestTime)
        {
            earliestTime = expectedFinish;
        }
    }

    return earliestTime;
}

float CScheduler::GetMaxDuration() const
{
    TTime duration = 0;
    for (const CTask &task: m_Tasks)
    {
        duration += task.GetDuration();
    }
    return float(duration);
}

float CScheduler::GetMinDuration() const
{
    TTime minDuration = TIME_MAX;
    for (const CTask &task: m_Tasks)
    {
        const TTime &taskDuration = task.GetDuration();
        if (taskDuration < minDuration)
        {
            minDuration = taskDuration;
        }
    }

    return float((minDuration * (TTime) m_Tasks.size()) / (TTime) m_Resources.size());
}

float CScheduler::GetMaxCost() const
{
    float mostExpRes = 0.f;
    for (const CResource &resource: m_Resources)
    {
        mostExpRes = fmaxf(mostExpRes, resource.GetSalary());
    }
    float maxCost = 0.f;
    for (const CTask &task: m_Tasks)
    {
        maxCost += (task.GetDuration() * mostExpRes);
    }
    return maxCost;
}

float CScheduler::GetMinCost() const
{
    float minExpRes = FLT_MAX;
    for (const CResource &resource: m_Resources)
    {
        minExpRes = fminf(minExpRes, resource.GetSalary());
    }
    float minCost = 0.f;
    for (const CTask &task: m_Tasks)
    {
        minCost += (task.GetDuration() * minExpRes);
    }
    return minCost;
}

float CScheduler::GetMaxAvgCashFlowDev() const
{
    return GetMaxCost();
}

float CScheduler::GetMinAvgCashFlowDev() const
{
    return 0.f;
}

float CScheduler::GetMaxSkillOveruse() const
{
    float maxOveruse = 0.f;
    for (const CTask &task: m_Tasks)
    {
        for (const SSkill &reqSkill: task.GetRequiredSkills())
        {
            TSkillLevel maxSkillLevel = 0;
            for (const CResource &resource: m_Resources)
            {
                TSkillLevel resSkillLevel = 0;
                if (resource.GetSkillLevel(reqSkill.m_TypeID, resSkillLevel) && resSkillLevel > maxSkillLevel)
                {
                    maxSkillLevel = resSkillLevel;
                }
            }
            maxOveruse += (maxSkillLevel - reqSkill.m_Level);
        }
    }
    return maxOveruse;
}

float CScheduler::GetMinSkillOveruse() const
{
    return 0.f;
}

float CScheduler::GetMaxAvgUseOfResTime() const
{
    static const float s_ExpectedUsedTime = (float) GetMaxDuration() / (float) m_Resources.size();
    return s_ExpectedUsedTime * (m_Resources.size() - 1);
}

float CScheduler::GetMinAvgUseOfResTime() const
{
    return 0.f;
}

void CScheduler::SetInstanceName(const std::string &instanceName)
{
    m_InstanceName = instanceName;
}

std::string CScheduler::GetInstanceName() const
{
    return m_InstanceName;
}

optimizer\src\problem\problems\MSRCPSP\CSkill.cpp
=============
#include "CSkill.h"

SSkill::SSkill()
        : m_TypeID(0), m_Level(0)
{
}

SSkill::SSkill(TSkillType typeID, TSkillLevel level)
        : m_TypeID(typeID), m_Level(level)
{
}


optimizer\src\problem\problems\MSRCPSP\CTask.cpp
=============
#include "CTask.h"

CTask::CTask(TTaskID id, const std::vector<SSkill> &skills, TTime duration, const std::vector<TTaskID> &predecessors)
        : m_ID(id), m_RequiredSkills(skills), m_Duration(duration), m_Start(-1), m_Predecessors(predecessors),
          m_ResourceID(-1), m_HasSuccessors(false)
{
}

bool CTask::CanBeExecutedBy(const CResource &resource) const
{
    for (const SSkill &requiredSkill: m_RequiredSkills)
    {
        if (!resource.HasSkill(requiredSkill))
        {
            return false;
        }
    }

    return true;
}


optimizer\src\problem\problems\TSP\CTSP.cpp
=============
#include "CTSP.h"


optimizer\src\problem\problems\TTP\CTTP1.cpp
=============
#include "CTTP1.h"

CTTP1::CTTP1(CTTP2 &ttp2) : CTTP2(ttp2)
{
    m_ProblemEncoding.m_objectivesNumber = 1;

    m_MaxObjectiveValues = {
            m_TTPTemplate.GetMaxTravelTime() + (-m_TTPTemplate.GetMinProfit() * m_TTPTemplate.GetRentingRatio()),
    };

    m_MinObjectiveValues = {
            m_TTPTemplate.GetMinTravelTime() + (-m_TTPTemplate.GetMaxProfit() * m_TTPTemplate.GetRentingRatio()),
    };
}

void CTTP1::Evaluate(AIndividual& individual)
{
    CTTP2::Evaluate(individual);
    individual.m_NormalizedEvaluation = {individual.m_Evaluation[1] + (individual.m_Evaluation[0] * m_TTPTemplate.GetRentingRatio())};
}


optimizer\src\problem\problems\TTP\CTTP2.cpp
=============
#include "CTTP2.h"

#define TTP_SAVE_FIXED_GENES 1

CTTP2::CTTP2(CTTPTemplate &ttpBase) : m_TTPTemplate(ttpBase)
{
    CreateProblemEncoding();

    m_MaxObjectiveValues = {
            m_TTPTemplate.GetMaxTravelTime(),
            -m_TTPTemplate.GetMinProfit()
    };

    m_MinObjectiveValues = {
            m_TTPTemplate.GetMinTravelTime(),
            -m_TTPTemplate.GetMaxProfit()
    };
}

SProblemEncoding &CTTP2::GetProblemEncoding()
{
    return m_ProblemEncoding;
}

void CTTP2::Evaluate(AIndividual& individual)
{
    // Build solution
    auto &items = m_TTPTemplate.GetItems();
    auto &cityItems = m_TTPTemplate.GetCityItems();
    auto &distMtx = m_TTPTemplate.GetDistMtx();
    int capacity = m_TTPTemplate.GetCapacity();

    float minSpeed = m_TTPTemplate.GetMinSpeed();
    float maxSpeed = m_TTPTemplate.GetMaxSpeed();

    size_t itemsSize = m_TTPTemplate.GetItemsSize();
    size_t citiesSize = m_TTPTemplate.GetCitiesSize();
    std::vector<bool> selection(itemsSize, false);
    int currWeight = 0;

    // // Left to Right - different fixing heuristic
    // {
    //     size_t i = 0;
    //     while (i < itemsSize)
    //     {
    //         int w = items[i].m_Weight;
    //         if (ttpSolution[citiesSize + i] > 0 && currWeight + w <= capacity)
    //         {
    //             currWeight += w;
    //             selection[i] = true;
    //         }
    //         ++i;
    //     }
    // }

    // Ry ratio
    {
        const auto &itemsRatio = m_TTPTemplate.GetProfitRatioSortedItems();
        size_t i = 0;
        while (i < itemsSize)
        {
            size_t itemIdx = itemsRatio[i];
            int w = items[itemIdx].m_Weight;
            if (individual.m_Genotype.m_BoolGenotype[itemIdx] > 0 && currWeight + w <= capacity)
            {
                currWeight += w;
                selection[itemIdx] = true;
            }
#if TTP_SAVE_FIXED_GENES
            else
            {
                // Save back the zeroed item
                individual.m_Genotype.m_BoolGenotype[itemIdx] = 0;
            }
#endif
            ++i;
        }
    }

    // Evaluate
    float travellingTime = 0.f;
    currWeight = 0;
    int currentProfit = 0;

    // For each city
    for (size_t i = 0; i < citiesSize; ++i)
    {
        size_t cityIdx = individual.m_Genotype.m_IntGenotype[i];
        size_t nextCityIdx = individual.m_Genotype.m_IntGenotype[(i + 1) % citiesSize];

        const std::vector<size_t> &itemsInCity = cityItems[cityIdx];
        for (const size_t &itemIdx: itemsInCity)
        {
            if (selection[itemIdx])
            {
                currWeight += items[itemIdx].m_Weight;
                currentProfit += items[itemIdx].m_Profit;
            }
        }

        float velocity = maxSpeed - ((float) currWeight * ((maxSpeed - minSpeed) / (float) capacity));
        velocity = fmaxf(velocity, minSpeed);
        travellingTime += distMtx[cityIdx][nextCityIdx] / velocity;
    }

    // Assign evaluation values, we assume this bi-objective problem
    individual.m_Evaluation =
            {
                    travellingTime,
                    (float) -currentProfit // invert the profit (min -> optimum)
            };

    // Normalize
    for (int i = 0; i < 2; i++)
    {
        individual.m_NormalizedEvaluation[i] = (individual.m_Evaluation[i] - m_MinObjectiveValues[i]) / (m_MaxObjectiveValues[i] - m_MinObjectiveValues[i]);
    }

}

void CTTP2::LogSolution(AIndividual& individual)
{
    
}

void CTTP2::CreateProblemEncoding()
{
    size_t citiesSize = m_TTPTemplate.GetCitiesSize();
    size_t itemsSize = m_TTPTemplate.GetItemsSize();

    SEncodingSection citiesSection = SEncodingSection
            {
                    // city indices <0, n-1>
                    std::vector<SEncodingDescriptor>(citiesSize, SEncodingDescriptor{
                            (float) 0, (float) (citiesSize - 1)
                    }),
                    EEncodingType::PERMUTATION
            };

    SEncodingSection knapsackSection = SEncodingSection
            {
                    std::vector<SEncodingDescriptor>(itemsSize,
                                                     SEncodingDescriptor{(float) 0, (float) 1}),
                    EEncodingType::BINARY
            };

    m_ProblemEncoding = SProblemEncoding{2, {citiesSection, knapsackSection}, m_TTPTemplate.GetDistMtx()};
}



optimizer\src\problem\problems\TTP\CTTPTemplate.cpp
=============
#include "CTTPTemplate.h"
#include <algorithm>
#include <cfloat>
#include "TTPJavaEvalData.h"

#define USE_JAVA_MAXPROFIT 1

SCity::SCity(const int &id, const float &x, const float &y)
{
    m_ID = id;
    m_PosX = x;
    m_PosY = y;
}

SItem::SItem(const int &id, const int &profit, const int &weight, const int &nodeId)
{
    m_ID = id;
    m_Profit = profit;
    m_Weight = weight;
    m_NodeId = nodeId;
}

void CTTPTemplate::Clear()
{
    m_Cities.clear();
    m_Items.clear();
    m_Capacity = 0;
    m_MinSpeed = 0;
    m_MaxSpeed = 0;
    m_RentingRatio = 0;

    m_DistanceMatrix.clear();
    m_MinDistanceVec.clear();
    m_CityItems.clear();
    m_ProfitRatioSortedItems.clear();
}

void
CTTPTemplate::SetData(const std::vector<SCity> &cities, const std::vector<SItem> &items, int capacity, float minSpeed,
                      float maxSpeed, float rentingRatio)
{
    Clear();

    m_Cities = cities;
    m_Items = items;
    m_Capacity = capacity;
    m_MinSpeed = minSpeed;
    m_MaxSpeed = maxSpeed;
    m_RentingRatio = rentingRatio;

    CalculateContextData();
}

float CTTPTemplate::GetMaxTravelTime() const
{
    return CalculateMaxDistance() / m_MinSpeed;
}

float CTTPTemplate::GetMaxProfit() const
{
//#if USE_JAVA_MAXPROFIT
//    return g_TTPMaxProfit[m_FileName];
//#else
    std::vector<SItem> itemsCopy = m_Items;

    auto sortLambda = [](const SItem& lhv, const SItem& rhv) -> bool
    {
        // float r = (float)rhv.profit / (float)rhv.weight;
        // float l = (float)lhv.profit / (float)lhv.weight;
        // return r != l ? r < l : rhv.profit < lhv.profit;
        return ((float)rhv.m_Profit / (float)rhv.m_Weight) < ((float)lhv.m_Profit / (float)lhv.m_Weight);
    };

    std::sort(itemsCopy.begin(), itemsCopy.end(), sortLambda);

    size_t i = 0;
    int cap = itemsCopy[0].m_Weight;
    int maxProfit = itemsCopy[0].m_Profit;
    while (cap < m_Capacity && i < itemsCopy.size())
    {
        maxProfit += itemsCopy[i].m_Profit;
        cap += itemsCopy[i].m_Weight;
        ++i;
    }
    return (float)maxProfit;
//#endif
}

float CTTPTemplate::GetMinTravelTime() const
{
    return CalculateMinDistance() / m_MaxSpeed;
}

float CTTPTemplate::GetMinProfit() const
{
    return 0.f;
}

float CTTPTemplate::CalculateMaxDistance() const
{
    // Based on Java impl
    return CalculateMinDistance() * 2.f;
}

float CTTPTemplate::CalculateMinDistance() const
{
    float dist = 0.f;
    size_t dim = m_DistanceMatrix.size();
    for (size_t i = 0; i < dim; ++i)
    {
        float minDist = FLT_MAX;
        for (size_t j = 0; j < dim; ++j)
        {
            if (i != j)
            {
                minDist = fminf(minDist, m_DistanceMatrix[i][j]);
            }
        }
        dist += minDist;
    }
    return dist;
}

void CTTPTemplate::CalculateContextData()
{
    size_t dim = m_Cities.size();
    m_DistanceMatrix = std::vector<std::vector<float>>(dim, std::vector<float>(dim, 0.f));
    for (size_t i = 0; i < dim; ++i)
    {
        for (size_t j = i + 1; j < dim; ++j)
        {
            // Use ceil distance
            float dist = ceilf(sqrtf(powf(m_Cities[i].m_PosX - m_Cities[j].m_PosX, 2) +
                                     powf(m_Cities[i].m_PosY - m_Cities[j].m_PosY, 2)));
            m_DistanceMatrix[i][j] = m_DistanceMatrix[j][i] = dist;
        }
    }

    // Calculate minimum distance vector
    m_MinDistanceVec = std::vector<float>(dim, 0.f);
    for (size_t i = 0; i < dim; ++i)
    {
        float minDist = FLT_MAX;
        for (size_t j = 0; j < dim; ++j)
        {
            if (i != j)
            {
                minDist = fminf(minDist, m_DistanceMatrix[i][j]);
            }
        }
        m_MinDistanceVec[i] = minDist;
    }

    m_CityItems = std::vector<std::vector<size_t>>(dim, std::vector<size_t>());
    for (const SItem &item: m_Items)
    {
#if USE_EOK
        if (item.id == 0) continue;
#endif
        // Convert id to index (we assume they are ordered)
        m_CityItems[item.m_NodeId - 1].emplace_back(item.m_ID - 1);
    }

    // Sort by best profit / weight to worst
    std::vector<std::pair<float, size_t>> itemsRatio;
    itemsRatio.reserve(m_Items.size());
    for (size_t i = 0; i < m_Items.size(); ++i)
    {
#if USE_EOK
        if (m_Items[i].id == 0)
        {
            itemsRatio.emplace_back(0.f, i);
            continue;
        }
#endif
        const SItem &item = m_Items[i];
        itemsRatio.emplace_back((float) item.m_Profit / (float) item.m_Weight, i);
    }

    auto sortLambda = [](const std::pair<float, size_t> &lhv, const std::pair<float, size_t> &rhv) -> bool
    {
        return rhv.first < lhv.first;
    };

    std::sort(itemsRatio.begin(), itemsRatio.end(), sortLambda);

    m_ProfitRatioSortedItems.clear();
    m_ProfitRatioSortedItems.reserve(itemsRatio.size());
    for (const std::pair<float, size_t> &itemRatio: itemsRatio)
    {
        m_ProfitRatioSortedItems.push_back(itemRatio.second);
    }
}


optimizer\src\utils\fileReader\CReadUtils.cpp
=============
#include "CReadUtils.h"
#include <fstream>
#include <sstream>
#include <sys/stat.h> // Library for file system statistics

bool CReadUtils::fileExists(const char *path)
{
    struct stat buffer{}; // Create a stat structure
    return (stat(path, &buffer) == 0); // Return true if the file exists
}

bool CReadUtils::ReadKeyValueString(const std::string &line, const std::string &delimiter, std::string &keyString,
                                    std::string &valueString)
{
    size_t delimiterPos = line.find(delimiter);
    if (delimiterPos > 0 && delimiterPos < line.length())
    {
        keyString = line.substr(0, delimiterPos);
        valueString = line.substr(delimiterPos + 1, line.length() - delimiterPos);
        return true;
    }
    return false;
}

bool CReadUtils::GotoReadSizeByKey(std::ifstream &fileStream, const std::string &lineKey, const std::string &delimiter,
                                   size_t &val)
{
    std::string line;
    if (CReadUtils::GotoLineByKey(fileStream, lineKey, line))
    {
        return CReadUtils::ReadSizeByKey(line, lineKey, delimiter, val);
    }
    return false;
}

bool
CReadUtils::GotoReadIntegerByKey(std::ifstream &fileStream, const std::string &lineKey, const std::string &delimiter,
                                 int &val)
{
    std::string line;
    if (CReadUtils::GotoLineByKey(fileStream, lineKey, line))
    {
        return CReadUtils::ReadIntegerByKey(line, lineKey, delimiter, val);
    }
    return false;
}

bool CReadUtils::GotoReadFloatByKey(std::ifstream &fileStream, const std::string &lineKey, const std::string &delimiter,
                                    float &val)
{
    std::string line;
    if (CReadUtils::GotoLineByKey(fileStream, lineKey, line))
    {
        return CReadUtils::ReadFloatByKey(line, lineKey, delimiter, val);
    }
    return false;
}

bool
CReadUtils::GotoReadStringByKey(std::ifstream &fileStream, const std::string &lineKey, const std::string &delimiter,
                                std::string &val)
{
    std::string line;
    if (CReadUtils::GotoLineByKey(fileStream, lineKey, line))
    {
        return CReadUtils::ReadStringByKey(line, lineKey, delimiter, val);
    }
    return false;
}

bool CReadUtils::GoToReadFloatByKeyAndRegex(std::ifstream& fileStream, const std::string& lineKey, const std::regex& regex, float& val)
{
    std::string line;
    if (CReadUtils::GotoLineByKey(fileStream, lineKey, line))
    {
        std::smatch match;
        if (std::regex_search(line, match, regex)) {
            val = std::stof(match[0]);
            return true;
        }
        return true;
    }
    return false;
}

bool CReadUtils::GotoLineByKey(std::ifstream &fileStream, const std::string &lineKey, std::string &line)
{
    while (std::getline(fileStream, line))
    {
        if (line.rfind(lineKey, 0) == 0)
        {
            return true;
        }
    }
    return false;
}

bool CReadUtils::ReadSizeByKey(const std::string &line, const std::string &lineKey, const std::string &delimiter,
                               size_t &val)
{
    int integerVal = 0;
    if (ReadIntegerByKey(line, lineKey, delimiter, integerVal))
    {
        if (integerVal >= 0)
        {
            val = (size_t) integerVal;
            return true;
        }
    }
    return false;
}

bool CReadUtils::ReadIntegerByKey(const std::string &line, const std::string &lineKey, const std::string &delimiter,
                                  int &val)
{
    if (line.rfind(lineKey, 0) == 0)
    {
        size_t delimiterPos = line.find(delimiter);
        if (delimiterPos >= 0)
        {
            std::string stringVal = line.substr(delimiterPos + 1, line.length() - delimiterPos);
            val = std::stoi(stringVal);
            return true;
        }
    }
    return false;
}

bool CReadUtils::ReadFloatByKey(const std::string &line, const std::string &lineKey, const std::string &delimiter,
                                float &val)
{
    if (line.rfind(lineKey, 0) == 0)
    {
        size_t delimiterPos = line.find(delimiter);
        if (delimiterPos >= 0)
        {
            std::string stringVal = line.substr(delimiterPos + 1, line.length() - delimiterPos);
            val = std::stof(stringVal);
            return true;
        }
    }
    return false;
}

bool CReadUtils::ReadStringByKey(const std::string &line, const std::string &lineKey, const std::string &delimiter,
                                 std::string &val)
{
    if (line.rfind(lineKey, 0) == 0)
    {
        size_t delimiterPos = line.find(delimiter);
        if (delimiterPos >= 0)
        {
            val = line.substr(delimiterPos + 1, line.length() - delimiterPos);
            return true;
        }
    }
    return false;
}

void CReadUtils::ReadWeights(const std::string &rawWeightsString, std::vector<float> &objectiveWeights)
{
    std::istringstream stream(rawWeightsString.substr(1, rawWeightsString.length() - 2));
    std::string token;
    std::vector<float> values;

    while (std::getline(stream, token, ','))
    {
        values.push_back(std::stof(token));  // convert string to float
    }

    for (float &value: values)
    {
        objectiveWeights.emplace_back(value);
    }
}

std::vector<std::string> CReadUtils::SplitLine(const std::string& lineToSplit)
{
    auto const re = std::regex{R"(\s+)"};
    auto const vec = std::vector<std::string>(
        std::sregex_token_iterator{
            lineToSplit.begin(),
            lineToSplit.end(),
            re, -1
        },
        std::sregex_token_iterator{}
    );
    return vec;
}


optimizer\src\utils\logger\CExperimentLogger.cpp
=============

#include <fstream>
#include <iostream>
#include "CExperimentLogger.h"
#include "../../method/AMethod.h"
#include <string>
#include <algorithm>
#include <filesystem>

char* CExperimentLogger::m_OutputDirPath = nullptr;
std::vector<std::string> CExperimentLogger::m_Data;
std::string CExperimentLogger::m_OutputDataPathPrefix;
int CExperimentLogger::m_LastProgressLogged;
size_t CExperimentLogger::m_BufferSize = 10000;

void CExperimentLogger::CreateOutputDataPrefix() {
    // Create the base output directory if it doesn't exist
    std::filesystem::path baseDirPath(m_OutputDirPath);
    if (!std::filesystem::exists(baseDirPath)) {
        std::filesystem::create_directories(baseDirPath);
        std::cout << "Base directory created: " << baseDirPath << std::endl;
    }

    // Create the run-specific directory
    std::filesystem::path runDirPath = baseDirPath / ("run_" + std::to_string(AMethod::m_ExperimentRunCounter));
    if (!std::filesystem::exists(runDirPath)) {
        std::filesystem::create_directories(runDirPath);
        std::cout << "Run directory created: " << runDirPath << std::endl;
    }

    m_OutputDataPathPrefix = runDirPath.string();

    std::ifstream inFile(runDirPath.string() + "/results.csv");
    if (inFile) {
        throw std::runtime_error("Results file already exists: " + runDirPath.string() + "/results.csv, no experiment files created or overwritten");
    }
}

void CExperimentLogger::AddLine(const char* line)
{
    m_Data.emplace_back(line);
    if (m_Data.size() >= m_BufferSize)
    {
        LogData();
    }
}

void CExperimentLogger::LogData()
{
    std::ofstream outFile;
    std::string outputDataPath = m_OutputDataPathPrefix + "/data.csv";
    outFile.open(outputDataPath, std::ofstream::out | std::ofstream::app); // Open in append mode
    if (!outFile.is_open())
    {
        std::cerr << "Unable to open file: " << outputDataPath << std::endl;
    }

    for (const auto& line: m_Data)
    {
        outFile << line << std::endl;
    }
    outFile.close();
    m_Data.clear();
}

void CExperimentLogger::LogResult(const char* result)
{
    LogResult(result, "results.csv");
}

void CExperimentLogger::LogResult(const char* result, const char* fileName)
{
    std::ofstream outFile;
    std::filesystem::path runDirPath = std::filesystem::path(m_OutputDataPathPrefix) / fileName;
    OpenFileForWriting(runDirPath.string().c_str(), outFile);

    outFile << result;
    outFile.close();
}

void CExperimentLogger::LogProgress(const float progress)
{
    if (m_LastProgressLogged != (int)(progress * 100)) {
        std::cout << (int)(progress * 100) << std::endl;
        m_LastProgressLogged = (int)(progress * 100);
    }
}

void CExperimentLogger::OpenFileForWriting(const char* filePath, std::ofstream& outFile)
{
    std::ifstream inFile(filePath);
    outFile.open(filePath);
    if (!outFile.is_open())
    {
        throw std::runtime_error("Unable to open file: " + std::string(filePath));
    }
}

bool CExperimentLogger::WriteSchedulerToFile(const CScheduler& schedule, const AIndividual& solution)
{
    // TODO - generic logger should not contain Scheduler logic
    char archive_filename[256];
    std::string outputDataPath = m_OutputDataPathPrefix + "/best_solution.sol";
    snprintf(archive_filename, 256, "%s",outputDataPath.c_str());
    std::ofstream arch_file(archive_filename);

    arch_file << "Instance name;Duration;Cost;AvgCashFlowDev;AvgSkillOverUse;AvgUseOfResTime " << std::endl;
    
    arch_file << schedule.GetInstanceName() << ';' << solution.m_Evaluation[0] << ';' << solution.m_Evaluation[1] << ';' << solution.m_Evaluation[2] << ';' << solution.m_Evaluation[3] << ';' << solution.m_Evaluation[4] << ';' << std::endl;

    arch_file << "Hour;Resource assignments (resource ID - task ID - Duration-predecessors) " << std::endl;

    std::vector<int> startTimes = std::vector<int>();
    for (CTask task : schedule.GetTasks())
    {
        int startTime = task.GetStart();
        if (!std::count(startTimes.begin(), startTimes.end(), startTime))
            startTimes.push_back(startTime);
    }

    std::sort(startTimes.begin(), startTimes.end());

    for (int startTime : startTimes)
    {
        arch_file << startTime + 1;
        arch_file << ";";

        int taskId = 1;

        for (CTask task : schedule.GetTasks())
        {
            if (task.GetStart() == startTime)
            {
                TResourceID resourceID = task.GetResourceID();
                TTime duration = task.GetDuration();

                arch_file << resourceID << "-" << taskId << "-" << duration << "-";
                
                for (TTaskID id: task.GetPredecessors()) {
                    arch_file << id << ",";
                }

                arch_file << ";";
                    
            }

            taskId++;
        }

        arch_file << std::endl;
    }

    arch_file.close();
    return true;
}


optimizer\src\utils\logger\ErrorUtils.cpp
=============
#include <stdexcept>
#include "ErrorUtils.h"

void ErrorUtils::LowerThanZeroI(std::string objectName, std::string paramName, int paramValue)
{
    if (paramValue < 0) throw std::runtime_error(objectName + " parameter " + paramName + " lower than 0");
}

void ErrorUtils::LowerThanZeroF(std::string objectName, std::string paramName, float paramValue)
{
    if (paramValue < 0) throw std::runtime_error(objectName + " parameter " + paramName + " lower than 0");
}

void ErrorUtils::OutOfScopeF(std::string objectName, std::string paramName, float paramValue)
{
    if (paramValue < 0 || paramValue > 1.0) throw std::runtime_error(objectName + " parameter " + paramName + " out of [0,1] scope");
}


optimizer\src\utils\random\CRandom.cpp
=============
#include <algorithm>
#include "CRandom.h"

std::mt19937 CRandom::rng{std::random_device{}()};

void CRandom::SetSeed(unsigned int seed)
{
    rng.seed(seed);
}

int CRandom::GetBool()
{
    return (bool) GetInt(0, 2);
}

int CRandom::GetInt(int min, int max)
{
    std::uniform_int_distribution<int> dist(min, max - 1);
    return dist(rng);
}

float CRandom::GetFloat(float min, float max)
{
    std::uniform_real_distribution<float> dist(min, max);
    return dist(rng);
}

void CRandom::Shuffle(int start, int end, std::vector<int> &vector)
{
    std::shuffle(vector.begin() + start, vector.begin() + end, rng);
}

int CRandom::GetWeightedInt(const std::vector<float>& weights)
{
    std::vector<float> copiedWeights;
    std::copy(weights.begin(), weights.end(), std::back_inserter(copiedWeights));
    std::sort(copiedWeights.begin(), copiedWeights.end(), std::greater<float>());
    float sum_of_weight = 0;
    for (int i = 0; i < copiedWeights.size(); i++) {
        sum_of_weight += copiedWeights[i];
    }
    float rnd = CRandom::GetFloat(0, sum_of_weight);
    for (int i = 0; i < copiedWeights.size(); i++) {
        if (rnd < copiedWeights[i])
            return i;
        rnd -= copiedWeights[i];
    }
    return 0;
}


